# ==================================================
# Path: E:\HTMLCSS\PROJECT_ONTAP\Project_DEMO_DATA_2
# Detected tech: javascript, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
Project_DEMO_DATA_2/
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ constants.js
â”‚   â”œâ”€â”€ database.js
â”‚   â””â”€â”€ rabbitmq.js
â”œâ”€â”€ data/
â”‚   â””â”€â”€ datasource2/
â”‚       â”œâ”€â”€ danh_gia.csv
â”‚       â”œâ”€â”€ khach_hang.csv
â”‚       â”œâ”€â”€ nhanvien_cskh.csv
â”‚       â”œâ”€â”€ phieu_ho_tro.csv
â”‚       â””â”€â”€ phieu_xu_ly.csv
â”œâ”€â”€ logs/
â”œâ”€â”€ node_modules/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ deduplication/
â”‚   â”‚   â””â”€â”€ DeduplicationService.js
â”‚   â”œâ”€â”€ extract/
â”‚   â”‚   â”œâ”€â”€ CsvExtractor.js
â”‚   â”‚   â”œâ”€â”€ PostgresExtractor.js
â”‚   â”‚   â””â”€â”€ index.js
â”‚   â”œâ”€â”€ load/
â”‚   â”‚   â”œâ”€â”€ DataWarehouseLoader.js
â”‚   â”‚   â””â”€â”€ schema.sql
â”‚   â”œâ”€â”€ queue/
â”‚   â”‚   â”œâ”€â”€ Consumer.js
â”‚   â”‚   â”œâ”€â”€ Producer.js
â”‚   â”‚   â””â”€â”€ index.js
â”‚   â”œâ”€â”€ staging/
â”‚   â”‚   â”œâ”€â”€ StagingService.js
â”‚   â”‚   â””â”€â”€ schema.sql
â”‚   â”œâ”€â”€ transform/
â”‚   â”‚   â”œâ”€â”€ transformers/
â”‚   â”‚   â”‚   â”œâ”€â”€ EmailTransformer.js
â”‚   â”‚   â”‚   â”œâ”€â”€ HoTenTransformer.js
â”‚   â”‚   â”‚   â”œâ”€â”€ NgayThangTransformer.js
â”‚   â”‚   â”‚   â””â”€â”€ TrangThaiTransformer.js
â”‚   â”‚   â”œâ”€â”€ TransformEngine.js
â”‚   â”‚   â””â”€â”€ TransformService.js
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ ErrorLogger.js
â”‚   â”‚   â”œâ”€â”€ Logger.js
â”‚   â”‚   â””â”€â”€ helpers.js
â”‚   â””â”€â”€ validation/
â”‚       â”œâ”€â”€ rules/
â”‚       â”‚   â”œâ”€â”€ DonGia.rule.js
â”‚       â”‚   â”œâ”€â”€ Email.rule.js
â”‚       â”‚   â”œâ”€â”€ HoTen.rule.js
â”‚       â”‚   â”œâ”€â”€ NgaySinh.rule.js
â”‚       â”‚   â”œâ”€â”€ SoDienThoai.rule.js
â”‚       â”‚   â””â”€â”€ TrangThai.rule.js
â”‚       â”œâ”€â”€ RuleEngine.js
â”‚       â””â”€â”€ ValidationService.js
â”œâ”€â”€ .env
â”œâ”€â”€ README.md
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ index.js
â”œâ”€â”€ package-lock.json
â”œâ”€â”€ package.json
â””â”€â”€ source_dump.txt
```

## FILE CONTENTS

### index.js
```js
// index.js - Main ETL Pipeline Entry Point
require('dotenv').config();
const logger = require('./src/utils/Logger');
const dbManager = require('./config/database');
const rabbitMQ = require('./config/rabbitmq');

// Extract
const PostgresExtractor = require('./src/extract/PostgresExtractor');
const CsvExtractor = require('./src/extract/CsvExtractor');

// Queue
const Producer = require('./src/queue/Producer');
const Consumer = require('./src/queue/Consumer');

// Validation & Transform
const RuleEngine = require('./src/validation/RuleEngine');
const TransformEngine = require('./src/transform/TransformEngine');

// Deduplication & Load
const DeduplicationService = require('./src/deduplication/DeduplicationService');
const DataWarehouseLoader = require('./src/load/DataWarehouseLoader');

class ETLPipeline {
  constructor() {
    this.postgresExtractor = new PostgresExtractor();
    this.csvExtractor = new CsvExtractor();
    this.producer = new Producer();
    this.consumer = new Consumer();
    this.ruleEngine = new RuleEngine();
    this.transformEngine = new TransformEngine();
    this.deduplicationService = new DeduplicationService();
    this.dataWarehouseLoader = new DataWarehouseLoader();
  }

  /**
   * Cháº¡y toÃ n bá»™ ETL Pipeline
   */
  async run() {
    try {
      await logger.startPhase('ETL PIPELINE STARTED');
      const startTime = Date.now();

      // ============================================
      // PHASE 1: EXTRACT
      // ============================================
      await this.extractPhase();

      // ============================================
      // PHASE 2: QUEUE & STAGING
      // ============================================
      await this.queuePhase();

      // ============================================
      // PHASE 3: DATA QUALITY
      // ============================================
      await this.dataQualityPhase();

      // ============================================
      // PHASE 4: LOAD
      // ============================================
      await this.loadPhase();

      const duration = (Date.now() - startTime) / 1000;
      await logger.endPhase('ETL PIPELINE COMPLETED', {
        duration: `${duration}s`,
        status: 'SUCCESS'
      });

    } catch (error) {
      await logger.error('ETL Pipeline failed', error);
      throw error;
    } finally {
      await this.cleanup();
    }
  }

  /**
   * PHASE 1: Extract dá»¯ liá»‡u tá»« 2 data sources
   */
  async extractPhase() {
    await logger.startPhase('PHASE 1: EXTRACT');

    // Extract tá»« PostgreSQL (Data Source 1)
    const postgresData = await this.postgresExtractor.extractAll();
    await logger.success('âœ“ Extracted PostgreSQL data', {
      tables: Object.keys(postgresData).length,
      totalRecords: this.countRecords(postgresData)
    });

    // Validate CSV files
    await this.csvExtractor.validateFiles();

    // Extract tá»« CSV (Data Source 2)
    const csvData = await this.csvExtractor.extractAll();
    await logger.success('âœ“ Extracted CSV data', {
      files: Object.keys(csvData).length,
      totalRecords: this.countRecords(csvData)
    });

    this.extractedData = {
      postgres: postgresData,
      csv: csvData
    };

    await logger.endPhase('PHASE 1: EXTRACT');
  }

  /**
   * PHASE 2: Queue dá»¯ liá»‡u qua RabbitMQ vÃ  Ä‘Æ°a vÃ o Staging
   */
  async queuePhase() {
    await logger.startPhase('PHASE 2: QUEUE & STAGING');

    // Káº¿t ná»‘i RabbitMQ
    await rabbitMQ.connect();
    await this.producer.initialize();
    await this.consumer.initialize();

    // Producer: Äáº©y dá»¯ liá»‡u vÃ o queues
    await logger.info('Sending data to queues...');
    await this.producer.sendPostgresData(this.extractedData.postgres);
    await this.producer.sendCsvData(this.extractedData.csv);

    // Consumer: Nháº­n dá»¯ liá»‡u vÃ  lÆ°u vÃ o Staging
    await logger.info('Consuming data from queues...');
    await this.consumer.consumeAll();

    await logger.endPhase('PHASE 2: QUEUE & STAGING');
  }

  /**
   * PHASE 3: Data Quality - Validation, Deduplication, Transform
   */
  async dataQualityPhase() {
    await logger.startPhase('PHASE 3: DATA QUALITY');

    // Láº¥y dá»¯ liá»‡u tá»« Staging
    const stagingData = await this.consumer.stagingService.getAllData();

    // Sub-phase 3.1: Deduplication
    await logger.info('Starting deduplication...');
    const deduplicatedData = await this.deduplicationService.removeDuplicates(stagingData);
    await logger.success('âœ“ Deduplication completed', {
      originalRecords: this.countRecords(stagingData),
      afterDedup: this.countRecords(deduplicatedData),
      removed: this.countRecords(stagingData) - this.countRecords(deduplicatedData)
    });

    // Sub-phase 3.2: Validation
    await logger.info('Starting validation...');
    const validationResults = {};
    for (const [tableName, records] of Object.entries(deduplicatedData)) {
      const result = this.ruleEngine.validateBatch(records);
      validationResults[tableName] = result;
      
      await logger.info(`Validated ${tableName}`, {
        total: result.totalRecords,
        valid: result.validRecords,
        fixable: result.fixableRecords,
        unfixable: result.unfixableRecords
      });
    }

    // Sub-phase 3.3: Transform (fix fixable errors)
    await logger.info('Starting transformation...');
    const transformedData = {};
    for (const [tableName, records] of Object.entries(deduplicatedData)) {
      const validationResult = validationResults[tableName];
      const transformResult = await this.transformEngine.transformBatch(
        records,
        validationResult
      );
      transformedData[tableName] = transformResult.records;
      
      await logger.success(`âœ“ Transformed ${tableName}`, {
        transformed: transformResult.transformedRecords,
        skipped: transformResult.skippedRecords
      });
    }

    // Sub-phase 3.4: Re-validate sau transform
    await logger.info('Re-validating after transformation...');
    const finalValidationResults = {};
    const cleanData = {};
    const errorData = {};

    for (const [tableName, records] of Object.entries(transformedData)) {
      const result = this.ruleEngine.validateBatch(records);
      finalValidationResults[tableName] = result;

      // TÃ¡ch clean data vÃ  error data
      cleanData[tableName] = result.results
        .filter(r => r.isValid)
        .map(r => r.record);
      
      errorData[tableName] = result.results
        .filter(r => !r.isValid)
        .map(r => ({ record: r.record, errors: r.errors }));

      await logger.info(`Final validation for ${tableName}`, {
        clean: cleanData[tableName].length,
        stillInvalid: errorData[tableName].length
      });
    }

    // Log errors
    for (const [tableName, errors] of Object.entries(errorData)) {
      if (errors.length > 0) {
        await logger.error(`Unfixable errors in ${tableName}`, null, {
          count: errors.length,
          samples: errors.slice(0, 3)
        });
      }
    }

    this.cleanData = cleanData;
    this.errorData = errorData;

    await logger.endPhase('PHASE 3: DATA QUALITY');
  }

  /**
   * PHASE 4: Load clean data vÃ o Data Warehouse
   */
  async loadPhase() {
    await logger.startPhase('PHASE 4: LOAD TO DATA WAREHOUSE');

    await this.dataWarehouseLoader.initialize();
    
    // Load clean data
    const loadResult = await this.dataWarehouseLoader.loadAll(this.cleanData);
    
    await logger.success('âœ“ Data loaded to warehouse', loadResult);

    await logger.endPhase('PHASE 4: LOAD TO DATA WAREHOUSE');
  }

  /**
   * Cleanup resources
   */
  async cleanup() {
    await logger.info('Cleaning up resources...');
    await rabbitMQ.close();
    await dbManager.closeAll();
    await logger.success('âœ“ Cleanup completed');
  }

  /**
   * Helper: Äáº¿m tá»•ng records
   */
  countRecords(data) {
    return Object.values(data).reduce((sum, records) => sum + records.length, 0);
  }
}

// ============================================
// MAIN EXECUTION
// ============================================
async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘   ETL DATA INTEGRATION PIPELINE                           â•‘');
  console.log('â•‘   E-commerce & Customer Care System                       â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('');

  const pipeline = new ETLPipeline();
  
  try {
    await pipeline.run();
    console.log('');
    console.log('âœ… ETL Pipeline completed successfully!');
    process.exit(0);
  } catch (error) {
    console.error('');
    console.error('âŒ ETL Pipeline failed!');
    console.error(error);
    process.exit(1);
  }
}

// Run if this is the main module
if (require.main === module) {
  main();
}

module.exports = ETLPipeline;
```

### config\constants.js
```js
// constants.js - Chá»©a táº¥t cáº£ cÃ¡c giÃ¡ trá»‹ enum vÃ  constant

module.exports = {
  // Tráº¡ng thÃ¡i Ä‘Æ¡n hÃ ng
  TRANG_THAI_DON_HANG: {
    CHO_XU_LY: 'Chá» xá»­ lÃ½',
    DANG_CHUAN_BI: 'Äang chuáº©n bá»‹',
    DANG_GIAO: 'Äang giao',
    DA_GIAO: 'ÄÃ£ giao',
    HUY: 'Há»§y',
    TRA_HANG: 'Tráº£ hÃ ng',
    DANG_XU_LY: 'Äang xá»­ lÃ½' 
  },

  // Tráº¡ng thÃ¡i thanh toÃ¡n
  TRANG_THAI_THANH_TOAN: {
    CHUA_THANH_TOAN: 'ChÆ°a thanh toÃ¡n',
    DA_THANH_TOAN: 'ÄÃ£ thanh toÃ¡n',
    HOAN_TIEN: 'HoÃ n tiá»n',
    THAT_BAI: 'Tháº¥t báº¡i',
    THANH_CONG: 'ThÃ nh cÃ´ng', // <--- THÃŠM DÃ’NG NÃ€Y
    DANG_XU_LY: 'Äang xá»­ lÃ½'  // <--- THÃŠM DÃ’NG NÃ€Y
  },

  // PhÆ°Æ¡ng thá»©c thanh toÃ¡n
  PHUONG_THUC_THANH_TOAN: {
    TIEN_MAT: 'Tiá»n máº·t',
    CHUYEN_KHOAN: 'Chuyá»ƒn khoáº£n',
    THE_TIN_DUNG: 'Tháº» tÃ­n dá»¥ng',
    VI_DIEN_TU: 'VÃ­ Ä‘iá»‡n tá»­',
    COD: 'COD'
  },

  // Giá»›i tÃ­nh
  GIOI_TINH: {
    NAM: 'Nam',
    NU: 'Ná»¯',
    KHAC: 'KhÃ¡c'
  },

  // Loáº¡i khÃ¡ch hÃ ng
  LOAI_KHACH_HANG: {
    THUONG: 'ThÆ°á»ng',
    VIP: 'VIP',
    DOANH_NGHIEP: 'Doanh nghiá»‡p',
    MOI: 'Má»›i'
  },

  // Tráº¡ng thÃ¡i phiáº¿u há»— trá»£
  TRANG_THAI_PHIEU_HO_TRO: {
    MOI: 'Má»›i',
    DANG_XU_LY: 'Äang xá»­ lÃ½',
    CHO_PHAN_HOI: 'Chá» pháº£n há»“i',
    DA_GIAI_QUYET: 'ÄÃ£ giáº£i quyáº¿t',
    DONG: 'ÄÃ³ng',
    HUY: 'Há»§y'
  },

  // Äá»™ Æ°u tiÃªn
  DO_UU_TIEN: {
    THAP: 'Tháº¥p',
    TRUNG_BINH: 'Trung bÃ¬nh',
    CAO: 'Cao',
    KHAN_CAP: 'Kháº©n cáº¥p'
  },

  // Tráº¡ng thÃ¡i nhÃ¢n viÃªn
  TRANG_THAI_NHAN_VIEN: {
    DANG_LAM: 'Äang lÃ m',
    NGHI_PHEP: 'Nghá»‰ phÃ©p',
    DA_NGHI: 'ÄÃ£ nghá»‰'
  },

  // Chá»©c vá»¥
  CHUC_VU: {
    NHAN_VIEN: 'NhÃ¢n viÃªn',
    TRUONG_NHOM: 'TrÆ°á»Ÿng nhÃ³m',
    QUAN_LY: 'Quáº£n lÃ½',
    GIAM_DOC: 'GiÃ¡m Ä‘á»‘c'
  },

  // Káº¿t quáº£ xá»­ lÃ½
  KET_QUA_XU_LY: {
    THANH_CONG: 'ThÃ nh cÃ´ng',
    THAT_BAI: 'Tháº¥t báº¡i',
    DANG_XU_LY: 'Äang xá»­ lÃ½'
  },

  // Regex patterns
  REGEX: {
    EMAIL: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
    PHONE: /^(0|\+84)[0-9]{9,10}$/,
    MA_KHACH_HANG: /^KH\d{4}$/,
    MA_DON_HANG: /^DH\d{4}$/,
    MA_SAN_PHAM: /^SP\d{4}$/,
    MA_DANH_MUC: /^DM\d{4}$/,
    MA_THANH_TOAN: /^TT\d{4}$/,
    MA_PHIEU_HO_TRO: /^PHT\d{4}$/,
    MA_DANH_GIA: /^DG\d{4}$/,
    MA_NHAN_VIEN: /^NV\d{4}$/,
    MA_PHIEU_XU_LY: /^PXL\d{4}$/
  },

  // Validation limits
  LIMITS: {
    MIN_AGE: 13,
    MAX_AGE: 120,
    MIN_PRICE: 0,
    MAX_PRICE: 999999999,
    MIN_QUANTITY: 1,
    MAX_QUANTITY: 10000,
    MIN_RATING: 1,
    MAX_RATING: 5,
    MAX_NAME_LENGTH: 100,
    MAX_EMAIL_LENGTH: 100,
    MAX_PHONE_LENGTH: 20
  },

  // Error codes
  ERROR_CODES: {
    INVALID_FORMAT: 'E001',
    NULL_VALUE: 'E002',
    OUT_OF_RANGE: 'E003',
    DUPLICATE: 'E004',
    INVALID_REFERENCE: 'E005',
    INVALID_DATE: 'E006',
    INVALID_STATUS: 'E007'
  },

  // Transform actions
  TRANSFORM_ACTIONS: {
    UPPERCASE: 'uppercase',
    LOWERCASE: 'lowercase',
    TRIM: 'trim',
    CAPITALIZE: 'capitalize',
    NORMALIZE_VIETNAMESE: 'normalize_vietnamese',
    FORMAT_DATE: 'format_date',
    FORMAT_PHONE: 'format_phone',
    FORMAT_PRICE: 'format_price'
  }
};
```

### config\database.js
```js
// config/database.js - Quáº£n lÃ½ káº¿t ná»‘i PostgreSQL
const { Pool } = require('pg');
require('dotenv').config();

class DatabaseManager {
  constructor() {
    // Data Source 1 - E-commerce Database
    this.ds1Pool = new Pool({
      host: process.env.DS1_HOST,
      database: process.env.DS1_DATABASE,
      user: process.env.DS1_USER,
      password: process.env.DS1_PASSWORD,
      port: process.env.DS1_PORT,
      ssl: process.env.DS1_SSL === 'true' ? { rejectUnauthorized: false } : false,
      max: 10,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });

    // Staging Database
    this.stagingPool = new Pool({
      host: process.env.DS2_HOST,
      database: process.env.DS2_DATABASE,
      user: process.env.DS2_USER,
      password: process.env.DS2_PASSWORD,
      port: process.env.DS2_PORT,
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });

    // Data Warehouse (Final Clean Data)
    this.dwPool = new Pool({
      host: process.env.DW_HOST,
      database: process.env.DW_DATABASE,
      user: process.env.DW_USER,
      password: process.env.DW_PASSWORD,
      port: process.env.DW_PORT,
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });

    this.testConnections();
  }

  async testConnections() {
    try {
      // Test Data Source 1
      const ds1Client = await this.ds1Pool.connect();
      console.log('âœ… Connected to Data Source 1 (E-commerce DB)');
      ds1Client.release();

      // Test Staging
      const stagingClient = await this.stagingPool.connect();
      console.log('âœ… Connected to Staging Database');
      stagingClient.release();

      // Test Data Warehouse
      const dwClient = await this.dwPool.connect();
      console.log('âœ… Connected to Data Warehouse');
      dwClient.release();
    } catch (error) {
      console.error('âŒ Database connection error:', error.message);
      throw error;
    }
  }

  // Get Data Source 1 connection
  getDS1Pool() {
    return this.ds1Pool;
  }

  // Get Staging connection
  getStagingPool() {
    return this.stagingPool;
  }

  // Get Data Warehouse connection
  getDWPool() {
    return this.dwPool;
  }

  // Close all connections
  async closeAll() {
    await this.ds1Pool.end();
    await this.stagingPool.end();
    await this.dwPool.end();
    console.log('ğŸ”Œ All database connections closed');
  }
}

module.exports = new DatabaseManager();
```

### config\rabbitmq.js
```js
// config/rabbitmq.js - RabbitMQ Connection Manager
const amqp = require('amqplib');
require('dotenv').config();

class RabbitMQManager {
  constructor() {
    this.connection = null;
    this.channel = null;
    this.queues = {
      ds1: process.env.QUEUE_NAME_DS1 || 'datasource1_queue',
      ds2: process.env.QUEUE_NAME_DS2 || 'datasource2_queue',
      staging: process.env.QUEUE_NAME_STAGING || 'staging_queue'
    };
  }

  async connect() {
    try {
      this.connection = await amqp.connect(process.env.RABBITMQ_URL);
      this.channel = await this.connection.createChannel();
      
      // Khai bÃ¡o cÃ¡c queues
      await this.channel.assertQueue(this.queues.ds1, { durable: true });
      await this.channel.assertQueue(this.queues.ds2, { durable: true });
      await this.channel.assertQueue(this.queues.staging, { durable: true });

      console.log('âœ… Connected to RabbitMQ');
      console.log(`ğŸ“« Queues initialized: ${Object.values(this.queues).join(', ')}`);

      // Handle connection errors
      this.connection.on('error', (err) => {
        console.error('âŒ RabbitMQ connection error:', err.message);
      });

      this.connection.on('close', () => {
        console.log('ğŸ”Œ RabbitMQ connection closed');
      });

      return this.channel;
    } catch (error) {
      console.error('âŒ Failed to connect to RabbitMQ:', error.message);
      throw error;
    }
  }

  getChannel() {
    if (!this.channel) {
      throw new Error('RabbitMQ channel not initialized. Call connect() first.');
    }
    return this.channel;
  }

  getQueueName(source) {
    return this.queues[source];
  }

  async close() {
    if (this.channel) {
      await this.channel.close();
    }
    if (this.connection) {
      await this.connection.close();
    }
    console.log('ğŸ”Œ RabbitMQ connections closed');
  }
}

module.exports = new RabbitMQManager();
```

### src\deduplication\DeduplicationService.js
```js
// src/deduplication/DeduplicationService.js - Loáº¡i bá» dá»¯ liá»‡u trÃ¹ng láº·p
const logger = require('../utils/Logger');

class DeduplicationService {
  constructor() {
    // Äá»‹nh nghÄ©a primary keys cho tá»«ng báº£ng
    this.primaryKeys = {
      khach_hang: ['ma_khach_hang'],
      danh_muc: ['ma_danh_muc'],
      san_pham: ['ma_san_pham'],
      don_hang: ['ma_don_hang'],
      chi_tiet_don_hang: ['ma_don_hang', 'ma_san_pham'],
      thanh_toan: ['ma_thanh_toan'],
      phieu_ho_tro: ['ma_phieu_ho_tro'],
      danh_gia: ['ma_danh_gia'],
      nhanvien_cskh: ['ma_nhan_vien'],
      phieu_xu_ly: ['ma_phieu_xu_ly']
    };
  }

  /**
   * Loáº¡i bá» trÃ¹ng láº·p cho táº¥t cáº£ tables
   */
  async removeDuplicates(data) {
    await logger.startPhase('DEDUPLICATION');

    const deduplicatedData = {};
    const stats = {
      totalOriginal: 0,
      totalAfter: 0,
      totalRemoved: 0,
      byTable: {}
    };

    for (const [tableName, records] of Object.entries(data)) {
      if (!records || records.length === 0) {
        deduplicatedData[tableName] = [];
        continue;
      }

      const original = records.length;
      const deduplicated = this.deduplicateTable(tableName, records);
      const removed = original - deduplicated.length;

      deduplicatedData[tableName] = deduplicated;

      stats.totalOriginal += original;
      stats.totalAfter += deduplicated.length;
      stats.totalRemoved += removed;
      stats.byTable[tableName] = {
        original,
        after: deduplicated.length,
        removed
      };

      if (removed > 0) {
        await logger.warn(`Removed ${removed} duplicates from ${tableName}`, {
          original,
          after: deduplicated.length
        });
      } else {
        await logger.success(`No duplicates in ${tableName}`);
      }
    }

    await logger.endPhase('DEDUPLICATION', stats);

    return deduplicatedData;
  }

  /**
   * Loáº¡i bá» trÃ¹ng láº·p cho má»™t table
   */
  deduplicateTable(tableName, records) {
    const primaryKeys = this.primaryKeys[tableName];
    
    if (!primaryKeys) {
      logger.warn(`No primary keys defined for ${tableName}, skipping deduplication`);
      return records;
    }

    // Sá»­ dá»¥ng Map Ä‘á»ƒ track unique records
    const uniqueMap = new Map();

    for (const record of records) {
      // Táº¡o composite key tá»« primary keys
      const key = this.createCompositeKey(record, primaryKeys);
      
      if (!uniqueMap.has(key)) {
        uniqueMap.set(key, record);
      } else {
        // Náº¿u trÃ¹ng, giá»¯ record má»›i hÆ¡n (cÃ³ source tá»« data source nÃ o)
        const existing = uniqueMap.get(key);
        const updated = this.mergeRecords(existing, record);
        uniqueMap.set(key, updated);
      }
    }

    return Array.from(uniqueMap.values());
  }

  /**
   * Táº¡o composite key tá»« nhiá»u fields
   */
  createCompositeKey(record, keys) {
    return keys
      .map(key => {
        const value = record[key];
        return value !== null && value !== undefined ? String(value).toLowerCase() : 'null';
      })
      .join('|');
  }

  /**
   * Merge 2 records trÃ¹ng nhau (giá»¯ thÃ´ng tin Ä‘áº§y Ä‘á»§ hÆ¡n)
   */
  mergeRecords(existing, newRecord) {
    const merged = { ...existing };

    // Æ¯u tiÃªn giÃ¡ trá»‹ khÃ´ng null/undefined
    for (const [key, value] of Object.entries(newRecord)) {
      if (value !== null && value !== undefined && value !== '') {
        if (!merged[key] || merged[key] === null || merged[key] === undefined || merged[key] === '') {
          merged[key] = value;
        }
      }
    }

    return merged;
  }

  /**
   * Loáº¡i bá» trÃ¹ng láº·p dá»±a trÃªn custom fields
   */
  deduplicateByFields(records, fields) {
    const uniqueMap = new Map();

    for (const record of records) {
      const key = this.createCompositeKey(record, fields);
      
      if (!uniqueMap.has(key)) {
        uniqueMap.set(key, record);
      }
    }

    return Array.from(uniqueMap.values());
  }

  /**
   * TÃ¬m duplicates (khÃ´ng xÃ³a, chá»‰ report)
   */
  findDuplicates(tableName, records) {
    const primaryKeys = this.primaryKeys[tableName];
    
    if (!primaryKeys) {
      return [];
    }

    const keyMap = new Map();
    const duplicates = [];

    for (const record of records) {
      const key = this.createCompositeKey(record, primaryKeys);
      
      if (keyMap.has(key)) {
        duplicates.push({
          key,
          existing: keyMap.get(key),
          duplicate: record
        });
      } else {
        keyMap.set(key, record);
      }
    }

    return duplicates;
  }

  /**
   * Thá»‘ng kÃª duplicates
   */
  async analyzeDuplicates(data) {
    const analysis = {};

    for (const [tableName, records] of Object.entries(data)) {
      const duplicates = this.findDuplicates(tableName, records);
      
      analysis[tableName] = {
        totalRecords: records.length,
        duplicateCount: duplicates.length,
        duplicatePercentage: ((duplicates.length / records.length) * 100).toFixed(2) + '%',
        samples: duplicates.slice(0, 3)
      };
    }

    await logger.info('Duplicate Analysis', analysis);
    return analysis;
  }

  /**
   * Loáº¡i bá» records hoÃ n toÃ n giá»‘ng nhau (all fields)
   */
  removeExactDuplicates(records) {
    const uniqueMap = new Map();

    for (const record of records) {
      const key = JSON.stringify(record);
      uniqueMap.set(key, record);
    }

    return Array.from(uniqueMap.values());
  }

  /**
   * Merge khÃ¡ch hÃ ng tá»« 2 data sources
   * (KhÃ¡ch hÃ ng cÃ³ thá»ƒ xuáº¥t hiá»‡n á»Ÿ cáº£ 2 nguá»“n)
   */
  mergeKhachHang(ds1Records, ds2Records) {
    const merged = new Map();

    // Add táº¥t cáº£ tá»« ds1
    for (const record of ds1Records) {
      const key = this.createCompositeKey(record, ['ma_khach_hang']);
      merged.set(key, { ...record, sources: ['ds1'] });
    }

    // Merge vá»›i ds2
    for (const record of ds2Records) {
      const key = this.createCompositeKey(record, ['ma_khach_hang']);
      
      if (merged.has(key)) {
        // Merge thÃ´ng tin
        const existing = merged.get(key);
        const mergedRecord = this.mergeRecords(existing, record);
        mergedRecord.sources = ['ds1', 'ds2'];
        merged.set(key, mergedRecord);
      } else {
        merged.set(key, { ...record, sources: ['ds2'] });
      }
    }

    return Array.from(merged.values());
  }
}

module.exports = DeduplicationService;
```

### src\extract\CsvExtractor.js
```js
// src/extract/CsvExtractor.js - Äá»c dá»¯ liá»‡u tá»« CSV files
const fs = require('fs');
const path = require('path');
const csv = require('csv-parser');
const logger = require('../utils/Logger');

class CsvExtractor {
  constructor() {
    this.csvPath = process.env.CSV_PATH || './data/datasource2';
    this.csvFiles = [
      'khach_hang.csv',
      'phieu_ho_tro.csv',
      'danh_gia.csv',
      'nhanvien_cskh.csv',
      'phieu_xu_ly.csv'
    ];
  }

  // Extract táº¥t cáº£ CSV files
  async extractAll() {
    await logger.startPhase('EXTRACT - CSV Data Source 2');
    
    const results = {};
    let totalRecords = 0;

    try {
      for (const fileName of this.csvFiles) {
        const tableName = path.basename(fileName, '.csv');
        await logger.info(`Extracting CSV: ${fileName}`);
        
        const data = await this.extractCsv(fileName);
        results[tableName] = data;
        totalRecords += data.length;

        await logger.success(`âœ“ Extracted ${data.length} records from ${fileName}`);
      }

      await logger.endPhase('EXTRACT - CSV Data Source 2', {
        totalFiles: this.csvFiles.length,
        totalRecords: totalRecords
      });

      return results;
    } catch (error) {
      await logger.error('Failed to extract from CSV files', error);
      throw error;
    }
  }

  // Extract má»™t file CSV cá»¥ thá»ƒ
  async extractCsv(fileName) {
    return new Promise((resolve, reject) => {
      const results = [];
      const filePath = path.join(this.csvPath, fileName);

      // Kiá»ƒm tra file tá»“n táº¡i
      if (!fs.existsSync(filePath)) {
        const error = new Error(`CSV file not found: ${filePath}`);
        logger.error(`File not found: ${fileName}`, error);
        reject(error);
        return;
      }

      fs.createReadStream(filePath)
        .pipe(csv({
          skipEmptyLines: true,
          trim: true,
          // Xá»­ lÃ½ headers vá»›i whitespace
          mapHeaders: ({ header }) => header.trim()
        }))
        .on('data', (row) => {
          // Trim táº¥t cáº£ cÃ¡c giÃ¡ trá»‹
          const cleanedRow = {};
          for (const key in row) {
            cleanedRow[key] = typeof row[key] === 'string' ? row[key].trim() : row[key];
          }
          results.push(cleanedRow);
        })
        .on('end', () => {
          resolve(results);
        })
        .on('error', (error) => {
          logger.error(`Error reading CSV: ${fileName}`, error);
          reject(error);
        });
    });
  }

  // Extract CSV vá»›i filter
  async extractWithFilter(fileName, filterFn) {
    const allData = await this.extractCsv(fileName);
    const filteredData = allData.filter(filterFn);
    
    await logger.info(`Filtered ${filteredData.length}/${allData.length} records from ${fileName}`);
    return filteredData;
  }

  // Extract vÃ  convert types
  async extractWithTypeConversion(fileName, typeMap) {
    const data = await this.extractCsv(fileName);
    
    return data.map(row => {
      const converted = { ...row };
      for (const [field, type] of Object.entries(typeMap)) {
        if (converted[field] !== undefined && converted[field] !== null && converted[field] !== '') {
          switch (type) {
            case 'number':
              converted[field] = parseFloat(converted[field]);
              break;
            case 'integer':
              converted[field] = parseInt(converted[field]);
              break;
            case 'boolean':
              converted[field] = converted[field].toLowerCase() === 'true';
              break;
            case 'date':
              converted[field] = new Date(converted[field]);
              break;
            // Máº·c Ä‘á»‹nh giá»¯ nguyÃªn string
          }
        }
      }
      return converted;
    });
  }

  // Kiá»ƒm tra táº¥t cáº£ CSV files cÃ³ tá»“n táº¡i khÃ´ng
  async validateFiles() {
    const missingFiles = [];
    
    for (const fileName of this.csvFiles) {
      const filePath = path.join(this.csvPath, fileName);
      if (!fs.existsSync(filePath)) {
        missingFiles.push(fileName);
      }
    }

    if (missingFiles.length > 0) {
      await logger.error('Missing CSV files', null, { missingFiles });
      throw new Error(`Missing CSV files: ${missingFiles.join(', ')}`);
    }

    await logger.success('All CSV files validated');
    return true;
  }
}

module.exports = CsvExtractor;
```

### src\extract\index.js
```js

```

### src\extract\PostgresExtractor.js
```js
// src/extract/PostgresExtractor.js - Äá»c dá»¯ liá»‡u tá»« PostgreSQL
const dbManager = require('../../config/database');
const logger = require('../utils/Logger');

class PostgresExtractor {
  constructor() {
    this.pool = dbManager.getDS1Pool();
    this.tables = [
      'khach_hang',
      'danh_muc',
      'san_pham',
      'don_hang',
      'chi_tiet_don_hang',
      'thanh_toan'
    ];
  }

  // Extract táº¥t cáº£ dá»¯ liá»‡u tá»« Data Source 1
  async extractAll() {
    await logger.startPhase('EXTRACT - PostgreSQL Data Source 1');
    
    const results = {};
    let totalRecords = 0;

    try {
      for (const tableName of this.tables) {
        await logger.info(`Extracting table: ${tableName}`);
        
        const data = await this.extractTable(tableName);
        results[tableName] = data;
        totalRecords += data.length;

        await logger.success(`âœ“ Extracted ${data.length} records from ${tableName}`);
      }

      await logger.endPhase('EXTRACT - PostgreSQL Data Source 1', {
        totalTables: this.tables.length,
        totalRecords: totalRecords
      });

      return results;
    } catch (error) {
      await logger.error('Failed to extract from PostgreSQL', error);
      throw error;
    }
  }

  // Extract má»™t báº£ng cá»¥ thá»ƒ
  async extractTable(tableName) {
    try {
      const query = `SELECT * FROM ${tableName}`;
      const result = await this.pool.query(query);
      
      return result.rows;
    } catch (error) {
      await logger.error(`Error extracting table ${tableName}`, error);
      throw error;
    }
  }

  // Extract vá»›i Ä‘iá»u kiá»‡n
  async extractWithCondition(tableName, condition, params = []) {
    try {
      const query = `SELECT * FROM ${tableName} WHERE ${condition}`;
      const result = await this.pool.query(query, params);
      
      await logger.info(`Extracted ${result.rows.length} records from ${tableName} with condition`);
      return result.rows;
    } catch (error) {
      await logger.error(`Error extracting ${tableName} with condition`, error);
      throw error;
    }
  }

  // Extract theo batch (phÃ¢n trang)
  async extractBatch(tableName, batchSize = 1000, offset = 0) {
    try {
      const query = `SELECT * FROM ${tableName} LIMIT $1 OFFSET $2`;
      const result = await this.pool.query(query, [batchSize, offset]);
      
      return result.rows;
    } catch (error) {
      await logger.error(`Error extracting batch from ${tableName}`, error);
      throw error;
    }
  }

  // Äáº¿m tá»•ng sá»‘ records
  async countRecords(tableName) {
    try {
      const query = `SELECT COUNT(*) as total FROM ${tableName}`;
      const result = await this.pool.query(query);
      return parseInt(result.rows[0].total);
    } catch (error) {
      await logger.error(`Error counting records in ${tableName}`, error);
      return 0;
    }
  }

  // Extract vá»›i JOIN (náº¿u cáº§n)
  async extractWithJoin(query) {
    try {
      const result = await this.pool.query(query);
      return result.rows;
    } catch (error) {
      await logger.error('Error executing join query', error);
      throw error;
    }
  }
}

module.exports = PostgresExtractor;
```

### src\load\DataWarehouseLoader.js
```js
// src/load/DataWarehouseLoader.js - Load clean data vÃ o Data Warehouse
const dbManager = require('../../config/database');
const logger = require('../utils/Logger');

class DataWarehouseLoader {
  constructor() {
    this.pool = dbManager.getDWPool();
    this.initialized = false;
  }

  /**
   * Khá»Ÿi táº¡o Data Warehouse schema
   */
  async initialize() {
    if (this.initialized) return;

    await logger.info('Initializing Data Warehouse...');

    try {
      await this.createWarehouseTables();
      this.initialized = true;
      await logger.success('Data Warehouse initialized');
    } catch (error) {
      await logger.error('Failed to initialize Data Warehouse', error);
      throw error;
    }
  }

  /**
   * Táº¡o cÃ¡c báº£ng trong Data Warehouse
   */
  async createWarehouseTables() {
    const createTableSQL = `
      -- Dimension Tables
      
      CREATE TABLE IF NOT EXISTS dim_khach_hang (
        ma_khach_hang VARCHAR(10) PRIMARY KEY,
        ho_ten VARCHAR(100) NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        so_dien_thoai VARCHAR(20),
        dia_chi VARCHAR(255),
        ngay_sinh DATE,
        ngay_dang_ky DATE,
        gioi_tinh VARCHAR(10),
        loai_khach_hang VARCHAR(50),
        sources VARCHAR(50),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE IF NOT EXISTS dim_danh_muc (
        ma_danh_muc VARCHAR(10) PRIMARY KEY,
        ten_danh_muc VARCHAR(100) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE IF NOT EXISTS dim_san_pham (
        ma_san_pham VARCHAR(10) PRIMARY KEY,
        ten_san_pham VARCHAR(150) NOT NULL,
        mo_ta TEXT,
        ma_danh_muc VARCHAR(10) REFERENCES dim_danh_muc(ma_danh_muc),
        don_gia DECIMAL(12,2),
        ton_kho INT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE IF NOT EXISTS dim_nhanvien_cskh (
        ma_nhan_vien VARCHAR(10) PRIMARY KEY,
        ho_ten VARCHAR(100) NOT NULL,
        email VARCHAR(100) UNIQUE,
        so_dien_thoai VARCHAR(20),
        chuc_vu VARCHAR(50),
        phong_ban VARCHAR(50),
        ngay_tuyen_dung DATE,
        trang_thai VARCHAR(20),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      -- Fact Tables

      CREATE TABLE IF NOT EXISTS fact_don_hang (
        ma_don_hang VARCHAR(10) PRIMARY KEY,
        ma_khach_hang VARCHAR(10) REFERENCES dim_khach_hang(ma_khach_hang),
        ngay_dat DATE NOT NULL,
        tong_tien DECIMAL(12,2),
        trang_thai VARCHAR(50),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE IF NOT EXISTS fact_chi_tiet_don_hang (
        ma_don_hang VARCHAR(10) REFERENCES fact_don_hang(ma_don_hang) ON DELETE CASCADE,
        ma_san_pham VARCHAR(10) REFERENCES dim_san_pham(ma_san_pham),
        so_luong INT,
        don_gia DECIMAL(12,2),
        PRIMARY KEY (ma_don_hang, ma_san_pham)
      );

      CREATE TABLE IF NOT EXISTS fact_thanh_toan (
        ma_thanh_toan VARCHAR(10) PRIMARY KEY,
        ma_don_hang VARCHAR(10) REFERENCES fact_don_hang(ma_don_hang) ON DELETE CASCADE,
        ngay_thanh_toan DATE,
        so_tien DECIMAL(12,2),
        trang_thai VARCHAR(50),
        phuong_thuc VARCHAR(50),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE IF NOT EXISTS fact_phieu_ho_tro (
        ma_phieu_ho_tro VARCHAR(10) PRIMARY KEY,
        ma_khach_hang VARCHAR(10) REFERENCES dim_khach_hang(ma_khach_hang),
        loai_van_de VARCHAR(100),
        mo_ta TEXT,
        ngay_tao TIMESTAMP,
        trang_thai VARCHAR(50),
        do_uu_tien VARCHAR(20),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE IF NOT EXISTS fact_danh_gia (
        ma_danh_gia VARCHAR(10) PRIMARY KEY,
        ma_khach_hang VARCHAR(10) REFERENCES dim_khach_hang(ma_khach_hang),
        diem_danh_gia INT CHECK (diem_danh_gia BETWEEN 1 AND 5),
        nhan_xet TEXT,
        ngay_danh_gia DATE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE IF NOT EXISTS fact_phieu_xu_ly (
        ma_phieu_xu_ly VARCHAR(10) PRIMARY KEY,
        ma_phieu_ho_tro VARCHAR(10) REFERENCES fact_phieu_ho_tro(ma_phieu_ho_tro) ON DELETE CASCADE,
        ma_nhan_vien VARCHAR(10) REFERENCES dim_nhanvien_cskh(ma_nhan_vien),
        ngay_xu_ly TIMESTAMP,
        hanh_dong VARCHAR(100),
        ket_qua VARCHAR(50),
        ghi_chu TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      -- Indexes for performance
      CREATE INDEX IF NOT EXISTS idx_don_hang_khach_hang ON fact_don_hang(ma_khach_hang);
      CREATE INDEX IF NOT EXISTS idx_don_hang_ngay_dat ON fact_don_hang(ngay_dat);
      CREATE INDEX IF NOT EXISTS idx_phieu_ho_tro_khach_hang ON fact_phieu_ho_tro(ma_khach_hang);
      CREATE INDEX IF NOT EXISTS idx_phieu_ho_tro_trang_thai ON fact_phieu_ho_tro(trang_thai);
      CREATE INDEX IF NOT EXISTS idx_danh_gia_khach_hang ON fact_danh_gia(ma_khach_hang);
    `;

    await this.pool.query(createTableSQL);
    await logger.success('Data Warehouse tables created');
  }

  /**
   * Load táº¥t cáº£ clean data vÃ o warehouse
   */
  async loadAll(cleanData) {
    await logger.startPhase('LOADING TO DATA WAREHOUSE');

    const stats = {
      dimension_tables: {},
      fact_tables: {},
      total_loaded: 0
    };

    try {
      // Load theo thá»© tá»±: Dimensions trÆ°á»›c, Facts sau
      
      // 1. Load Dimension Tables
      await logger.info('Loading dimension tables...');
      
      stats.dimension_tables.dim_khach_hang = await this.loadTable('dim_khach_hang', cleanData.khach_hang || []);
      stats.dimension_tables.dim_danh_muc = await this.loadTable('dim_danh_muc', cleanData.danh_muc || []);
      stats.dimension_tables.dim_san_pham = await this.loadTable('dim_san_pham', cleanData.san_pham || []);
      stats.dimension_tables.dim_nhanvien_cskh = await this.loadTable('dim_nhanvien_cskh', cleanData.nhanvien_cskh || []);

      // 2. Load Fact Tables
      await logger.info('Loading fact tables...');
      
      stats.fact_tables.fact_don_hang = await this.loadTable('fact_don_hang', cleanData.don_hang || []);
      stats.fact_tables.fact_chi_tiet_don_hang = await this.loadTable('fact_chi_tiet_don_hang', cleanData.chi_tiet_don_hang || []);
      stats.fact_tables.fact_thanh_toan = await this.loadTable('fact_thanh_toan', cleanData.thanh_toan || []);
      stats.fact_tables.fact_phieu_ho_tro = await this.loadTable('fact_phieu_ho_tro', cleanData.phieu_ho_tro || []);
      stats.fact_tables.fact_danh_gia = await this.loadTable('fact_danh_gia', cleanData.danh_gia || []);
      stats.fact_tables.fact_phieu_xu_ly = await this.loadTable('fact_phieu_xu_ly', cleanData.phieu_xu_ly || []);

      // TÃ­nh tá»•ng
      stats.total_loaded = Object.values(stats.dimension_tables).reduce((a, b) => a + b, 0) +
                          Object.values(stats.fact_tables).reduce((a, b) => a + b, 0);

      await logger.endPhase('LOADING TO DATA WAREHOUSE', stats);
      return stats;

    } catch (error) {
      await logger.error('Failed to load data to warehouse', error);
      throw error;
    }
  }

  /**
   * Load data vÃ o má»™t table
   */
  async loadTable(tableName, records) {
    if (!records || records.length === 0) {
      await logger.info(`No data to load for ${tableName}`);
      return 0;
    }

    let loadedCount = 0;
    
    try {
      // Clear table trÆ°á»›c (optional, tÃ¹y yÃªu cáº§u)
      // await this.pool.query(`TRUNCATE TABLE ${tableName} CASCADE`);

      // Láº¥y columns tá»« record Ä‘áº§u tiÃªn (bá» qua source, inserted_at)
      const columns = Object.keys(records[0]).filter(col => 
        col !== 'source' && col !== 'inserted_at' && col !== 'sources'
      );
      
      const columnNames = columns.join(', ');

      for (const record of records) {
        const values = columns.map(col => record[col]);
        const placeholders = values.map((_, i) => `$${i + 1}`).join(', ');
        
        const insertSQL = `
          INSERT INTO ${tableName} (${columnNames}) 
          VALUES (${placeholders})
          ON CONFLICT DO NOTHING
        `;
        
        const result = await this.pool.query(insertSQL, values);
        if (result.rowCount > 0) {
          loadedCount++;
        }
      }

      await logger.success(`âœ“ Loaded ${loadedCount} records into ${tableName}`);
      return loadedCount;

    } catch (error) {
      await logger.error(`Failed to load ${tableName}`, error);
      throw error;
    }
  }

  /**
   * Verify data integrity
   */
  async verifyDataIntegrity() {
    await logger.info('Verifying data integrity...');

    const checks = [
      // Kiá»ƒm tra foreign keys
      {
        name: 'fact_don_hang references dim_khach_hang',
        query: `
          SELECT COUNT(*) as count 
          FROM fact_don_hang dh 
          LEFT JOIN dim_khach_hang kh ON dh.ma_khach_hang = kh.ma_khach_hang 
          WHERE kh.ma_khach_hang IS NULL
        `
      },
      {
        name: 'dim_san_pham references dim_danh_muc',
        query: `
          SELECT COUNT(*) as count 
          FROM dim_san_pham sp 
          LEFT JOIN dim_danh_muc dm ON sp.ma_danh_muc = dm.ma_danh_muc 
          WHERE sp.ma_danh_muc IS NOT NULL AND dm.ma_danh_muc IS NULL
        `
      }
    ];

    const results = [];
    for (const check of checks) {
      const result = await this.pool.query(check.query);
      const count = parseInt(result.rows[0].count);
      results.push({
        check: check.name,
        orphanedRecords: count,
        passed: count === 0
      });

      if (count > 0) {
        await logger.warn(`Integrity check failed: ${check.name} has ${count} orphaned records`);
      }
    }

    await logger.info('Data integrity verification completed', results);
    return results;
  }

  /**
   * Láº¥y thá»‘ng kÃª warehouse
   */
  async getWarehouseStats() {
    const tables = [
      'dim_khach_hang', 'dim_danh_muc', 'dim_san_pham', 'dim_nhanvien_cskh',
      'fact_don_hang', 'fact_chi_tiet_don_hang', 'fact_thanh_toan',
      'fact_phieu_ho_tro', 'fact_danh_gia', 'fact_phieu_xu_ly'
    ];

    const stats = {};
    for (const table of tables) {
      const result = await this.pool.query(`SELECT COUNT(*) as count FROM ${table}`);
      stats[table] = parseInt(result.rows[0].count);
    }

    return stats;
  }
}

module.exports = DataWarehouseLoader;
```

### src\queue\Consumer.js
```js
// src/queue/Consumer.js - Nháº­n dá»¯ liá»‡u tá»« RabbitMQ vÃ  Ä‘Æ°a vÃ o Staging
const rabbitMQ = require('../../config/rabbitmq');
const logger = require('../utils/Logger');
const StagingService = require('../staging/StagingService');

class Consumer {
  constructor() {
    this.channel = null;
    this.stagingService = new StagingService();
    this.processedMessages = 0;
    this.totalRecords = 0;
  }

  async initialize() {
    this.channel = rabbitMQ.getChannel();
    await this.stagingService.initialize();
    await logger.info('Consumer initialized');
  }

  /**
   * Consume messages tá»« má»™t queue
   */
  async consumeQueue(queueName) {
    try {
      await logger.startPhase(`CONSUMING QUEUE: ${queueName}`);

      return new Promise((resolve, reject) => {
        this.channel.consume(
          queueName,
          async (msg) => {
            if (msg) {
              try {
                const message = JSON.parse(msg.content.toString());
                await this.processMessage(message);
                
                // Acknowledge message
                this.channel.ack(msg);
                this.processedMessages++;
                this.totalRecords += message.recordCount || 0;

              } catch (error) {
                await logger.error('Error processing message', error, {
                  queue: queueName,
                  message: msg.content.toString().substring(0, 200)
                });
                
                // Reject vÃ  requeue náº¿u cáº§n
                this.channel.nack(msg, false, false);
              }
            }
          },
          { noAck: false }
        );

        // Giáº£ sá»­ consume trong 5 giÃ¢y (hoáº·c Ä‘áº¿n khi queue rá»—ng)
        setTimeout(async () => {
          await logger.endPhase(`CONSUMING QUEUE: ${queueName}`, {
            processedMessages: this.processedMessages,
            totalRecords: this.totalRecords
          });
          resolve();
        }, 5000);
      });

    } catch (error) {
      await logger.error(`Failed to consume queue: ${queueName}`, error);
      throw error;
    }
  }

  /**
   * Xá»­ lÃ½ má»™t message
   */
  async processMessage(message) {
    const { source, table, records, timestamp } = message;

    await logger.info(`Processing message from ${source}`, {
      table,
      recordCount: records.length,
      timestamp
    });

    // LÆ°u vÃ o Staging database
    await this.stagingService.insertRecords(table, records, source);

    await logger.success(`âœ“ Processed ${records.length} records from ${table}`);
  }

  /**
   * Consume cáº£ 2 queues (PostgreSQL vÃ  CSV)
   */
  async consumeAll() {
    await logger.startPhase('CONSUME - All Data Sources');

    try {
      // Consume PostgreSQL queue
      const ds1Queue = rabbitMQ.getQueueName('ds1');
      await this.consumeQueue(ds1Queue);

      // Consume CSV queue
      const ds2Queue = rabbitMQ.getQueueName('ds2');
      await this.consumeQueue(ds2Queue);

      await logger.endPhase('CONSUME - All Data Sources', {
        totalMessages: this.processedMessages,
        totalRecords: this.totalRecords
      });

      return {
        messagesProcessed: this.processedMessages,
        recordsProcessed: this.totalRecords
      };

    } catch (error) {
      await logger.error('Failed to consume all queues', error);
      throw error;
    }
  }

  /**
   * Consume vá»›i callback tÃ¹y chá»‰nh
   */
  async consumeWithCallback(queueName, callback) {
    await this.channel.consume(
      queueName,
      async (msg) => {
        if (msg) {
          try {
            const message = JSON.parse(msg.content.toString());
            await callback(message);
            this.channel.ack(msg);
          } catch (error) {
            await logger.error('Error in custom callback', error);
            this.channel.nack(msg, false, false);
          }
        }
      },
      { noAck: false }
    );
  }

  /**
   * Kiá»ƒm tra sá»‘ message trong queue
   */
  async getQueueStats(queueName) {
    try {
      const info = await this.channel.checkQueue(queueName);
      await logger.info(`Queue stats for ${queueName}`, {
        messageCount: info.messageCount,
        consumerCount: info.consumerCount
      });
      return info;
    } catch (error) {
      await logger.error(`Failed to get queue stats: ${queueName}`, error);
      return null;
    }
  }

  /**
   * Purge queue (xÃ³a táº¥t cáº£ messages)
   */
  async purgeQueue(queueName) {
    try {
      await this.channel.purgeQueue(queueName);
      await logger.warn(`Queue purged: ${queueName}`);
    } catch (error) {
      await logger.error(`Failed to purge queue: ${queueName}`, error);
    }
  }
}

module.exports = Consumer;
```

### src\queue\index.js
```js

```

### src\queue\Producer.js
```js
// src/queue/Producer.js - Äáº©y dá»¯ liá»‡u vÃ o RabbitMQ queues
const rabbitMQ = require('../../config/rabbitmq');
const logger = require('../utils/Logger');

class Producer {
  constructor() {
    this.channel = null;
  }

  async initialize() {
    this.channel = rabbitMQ.getChannel();
    await logger.info('Producer initialized');
  }

  /**
   * Gá»­i dá»¯ liá»‡u tá»« má»™t data source vÃ o queue
   * @param {string} queueName - TÃªn queue
   * @param {object} data - Dá»¯ liá»‡u cáº§n gá»­i (object chá»©a cÃ¡c table)
   * @param {string} sourceType - 'postgresql' hoáº·c 'csv'
   */
  async sendToQueue(queueName, data, sourceType) {
    try {
      await logger.info(`Sending data to queue: ${queueName}`, {
        sourceType,
        tables: Object.keys(data),
        totalRecords: this.countTotalRecords(data)
      });

      // Gá»­i tá»«ng table nhÆ° má»™t message riÃªng
      for (const [tableName, records] of Object.entries(data)) {
        const message = {
          source: sourceType,
          table: tableName,
          records: records,
          timestamp: new Date().toISOString(),
          recordCount: records.length
        };

        const sent = this.channel.sendToQueue(
          queueName,
          Buffer.from(JSON.stringify(message)),
          { persistent: true }
        );

        if (sent) {
          await logger.success(`âœ“ Sent ${records.length} records from ${tableName} to ${queueName}`);
        } else {
          await logger.warn(`Queue ${queueName} is full, waiting...`);
          // Äá»£i queue available
          await this.waitForDrain();
          // Retry
          this.channel.sendToQueue(
            queueName,
            Buffer.from(JSON.stringify(message)),
            { persistent: true }
          );
        }
      }

      await logger.success(`All data sent to queue: ${queueName}`);
      return true;
    } catch (error) {
      await logger.error(`Failed to send data to queue: ${queueName}`, error);
      throw error;
    }
  }

  /**
   * Gá»­i dá»¯ liá»‡u tá»« PostgreSQL data source
   */
  async sendPostgresData(data) {
    const queueName = rabbitMQ.getQueueName('ds1');
    return await this.sendToQueue(queueName, data, 'postgresql');
  }

  /**
   * Gá»­i dá»¯ liá»‡u tá»« CSV data source
   */
  async sendCsvData(data) {
    const queueName = rabbitMQ.getQueueName('ds2');
    return await this.sendToQueue(queueName, data, 'csv');
  }

  /**
   * Äáº¿m tá»•ng sá»‘ records
   */
  countTotalRecords(data) {
    return Object.values(data).reduce((sum, records) => sum + records.length, 0);
  }

  /**
   * Äá»£i queue available
   */
  waitForDrain() {
    return new Promise((resolve) => {
      this.channel.once('drain', resolve);
    });
  }

  /**
   * Gá»­i batch data (cho big data)
   */
  async sendBatch(queueName, tableName, records, batchSize = 1000) {
    const batches = [];
    for (let i = 0; i < records.length; i += batchSize) {
      batches.push(records.slice(i, i + batchSize));
    }

    await logger.info(`Sending ${batches.length} batches to queue`, {
      totalRecords: records.length,
      batchSize
    });

    for (let i = 0; i < batches.length; i++) {
      const message = {
        table: tableName,
        records: batches[i],
        batch: i + 1,
        totalBatches: batches.length,
        timestamp: new Date().toISOString()
      };

      this.channel.sendToQueue(
        queueName,
        Buffer.from(JSON.stringify(message)),
        { persistent: true }
      );

      await logger.debug(`Sent batch ${i + 1}/${batches.length} for ${tableName}`);
    }

    await logger.success(`All batches sent for ${tableName}`);
  }
}

module.exports = Producer;
```

### src\staging\StagingService.js
```js
// src/staging/StagingService.js - Quáº£n lÃ½ Staging Database
const dbManager = require("../../config/database");
const logger = require("../utils/Logger");

class StagingService {
  constructor() {
    this.pool = dbManager.getStagingPool();
    this.initialized = false;
  }

  /**
   * Khá»Ÿi táº¡o staging tables
   */
  async initialize() {
    if (this.initialized) return;

    await logger.info("Initializing staging database...");

    try {
      // Táº¡o schema cho staging náº¿u chÆ°a cÃ³
      await this.createStagingTables();

      // Clear staging data cÅ©
      await this.clearAllTables();

      this.initialized = true;
      await logger.success("Staging database initialized");
    } catch (error) {
      await logger.error("Failed to initialize staging database", error);
      throw error;
    }
  }

  /**
   * Táº¡o staging tables
   */
  async createStagingTables() {
    const tables = [
      // Tables tá»« Data Source 1
      `CREATE TABLE IF NOT EXISTS stg_khach_hang (
  ma_khach_hang VARCHAR(10),
  ho_ten VARCHAR(100),
  email VARCHAR(100),
  so_dien_thoai VARCHAR(20),
  dia_chi VARCHAR(255),
  ngay_sinh DATE,
  ngay_dang_ky DATE,
  gioi_tinh VARCHAR(10),
  loai_khach_hang VARCHAR(50), -- <<--- THÃŠM DÃ’NG NÃ€Y
  source VARCHAR(20),
  inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)`,

      `CREATE TABLE IF NOT EXISTS stg_danh_muc (
        ma_danh_muc VARCHAR(10),
        ten_danh_muc VARCHAR(100),
        source VARCHAR(20),
        inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

      `CREATE TABLE IF NOT EXISTS stg_san_pham (
        ma_san_pham VARCHAR(10),
        ten_san_pham VARCHAR(150),
        mo_ta TEXT,
        ma_danh_muc VARCHAR(10),
        don_gia DECIMAL(12,2),
        ton_kho INT,
        source VARCHAR(20),
        inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

      `CREATE TABLE IF NOT EXISTS stg_don_hang (
        ma_don_hang VARCHAR(10),
        ma_khach_hang VARCHAR(10),
        ngay_dat DATE,
        tong_tien DECIMAL(12,2),
        trang_thai VARCHAR(50),
        source VARCHAR(20),
        inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

      `CREATE TABLE IF NOT EXISTS stg_chi_tiet_don_hang (
        ma_don_hang VARCHAR(10),
        ma_san_pham VARCHAR(10),
        so_luong INT,
        don_gia DECIMAL(12,2),
        source VARCHAR(20),
        inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

      `CREATE TABLE IF NOT EXISTS stg_thanh_toan (
        ma_thanh_toan VARCHAR(10),
        ma_don_hang VARCHAR(10),
        ngay_thanh_toan DATE,
        so_tien DECIMAL(12,2),
        trang_thai VARCHAR(50),
        phuong_thuc VARCHAR(50),
        source VARCHAR(20),
        inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

      // Tables tá»« Data Source 2
      `CREATE TABLE IF NOT EXISTS stg_phieu_ho_tro (
        ma_phieu_ho_tro VARCHAR(10),
        ma_khach_hang VARCHAR(10),
        loai_van_de VARCHAR(100),
        mo_ta TEXT,
        ngay_tao TIMESTAMP,
        trang_thai VARCHAR(50),
        do_uu_tien VARCHAR(20),
        source VARCHAR(20),
        inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

      `CREATE TABLE IF NOT EXISTS stg_danh_gia (
        ma_danh_gia VARCHAR(10),
        ma_khach_hang VARCHAR(10),
        diem_danh_gia INT,
        nhan_xet TEXT,
        ngay_danh_gia DATE,
        source VARCHAR(20),
        inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

      `CREATE TABLE IF NOT EXISTS stg_nhanvien_cskh (
        ma_nhan_vien VARCHAR(10),
        ho_ten VARCHAR(100),
        email VARCHAR(100),
        so_dien_thoai VARCHAR(20),
        chuc_vu VARCHAR(50),
        phong_ban VARCHAR(50),
        ngay_tuyen_dung DATE,
        trang_thai VARCHAR(20),
        source VARCHAR(20),
        inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,

      `CREATE TABLE IF NOT EXISTS stg_phieu_xu_ly (
        ma_phieu_xu_ly VARCHAR(10),
        ma_phieu_ho_tro VARCHAR(10),
        ma_nhan_vien VARCHAR(10),
        ngay_xu_ly TIMESTAMP,
        hanh_dong VARCHAR(100),
        ket_qua VARCHAR(50),
        ghi_chu TEXT,
        source VARCHAR(20),
        inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,
    ];

    for (const createTableSQL of tables) {
      await this.pool.query(createTableSQL);
    }

    await logger.success("All staging tables created");
  }

  /**
   * Insert records vÃ o staging table
   */
  async insertRecords(tableName, records, source) {
    if (!records || records.length === 0) {
      return 0;
    }

    const stagingTableName = `stg_${tableName}`;

    try {
      // Láº¥y columns tá»« record Ä‘áº§u tiÃªn
      const columns = Object.keys(records[0]);
      const columnNames = [...columns, "source"].join(", ");

      let insertedCount = 0;

      // Insert tá»«ng record
      for (const record of records) {
        const values = columns.map((col) => record[col]);
        values.push(source);

        const placeholders = values.map((_, i) => `$${i + 1}`).join(", ");
        const insertSQL = `INSERT INTO ${stagingTableName} (${columnNames}) VALUES (${placeholders})`;

        await this.pool.query(insertSQL, values);
        insertedCount++;
      }

      await logger.success(
        `Inserted ${insertedCount} records into ${stagingTableName}`
      );
      return insertedCount;
    } catch (error) {
      await logger.error(`Failed to insert into ${stagingTableName}`, error);
      throw error;
    }
  }

  /**
   * Láº¥y táº¥t cáº£ dá»¯ liá»‡u tá»« staging
   */
  async getAllData() {
    const tables = [
      "khach_hang",
      "danh_muc",
      "san_pham",
      "don_hang",
      "chi_tiet_don_hang",
      "thanh_toan",
      "phieu_ho_tro",
      "danh_gia",
      "nhanvien_cskh",
      "phieu_xu_ly",
    ];

    const data = {};

    for (const table of tables) {
      const stagingTableName = `stg_${table}`;
      try {
        const result = await this.pool.query(
          `SELECT * FROM ${stagingTableName}`
        );
        data[table] = result.rows;
      } catch (error) {
        await logger.warn(`Table ${stagingTableName} might not exist or empty`);
        data[table] = [];
      }
    }

    return data;
  }

  /**
   * Clear táº¥t cáº£ staging tables
   */
  async clearAllTables() {
    const tables = [
      "stg_khach_hang",
      "stg_danh_muc",
      "stg_san_pham",
      "stg_don_hang",
      "stg_chi_tiet_don_hang",
      "stg_thanh_toan",
      "stg_phieu_ho_tro",
      "stg_danh_gia",
      "stg_nhanvien_cskh",
      "stg_phieu_xu_ly",
    ];

    for (const table of tables) {
      try {
        await this.pool.query(`TRUNCATE TABLE ${table} CASCADE`);
      } catch (error) {
        // Table might not exist yet
      }
    }

    await logger.info("Staging tables cleared");
  }

  /**
   * Äáº¿m records trong staging table
   */
  async countRecords(tableName) {
    const stagingTableName = `stg_${tableName}`;
    try {
      const result = await this.pool.query(
        `SELECT COUNT(*) as count FROM ${stagingTableName}`
      );
      return parseInt(result.rows[0].count);
    } catch (error) {
      return 0;
    }
  }

  /**
   * Láº¥y thá»‘ng kÃª staging
   */
  async getStats() {
    const tables = [
      "khach_hang",
      "danh_muc",
      "san_pham",
      "don_hang",
      "chi_tiet_don_hang",
      "thanh_toan",
      "phieu_ho_tro",
      "danh_gia",
      "nhanvien_cskh",
      "phieu_xu_ly",
    ];

    const stats = {};
    let total = 0;

    for (const table of tables) {
      const count = await this.countRecords(table);
      stats[table] = count;
      total += count;
    }

    stats.total = total;
    return stats;
  }
}

module.exports = StagingService;

```

### src\transform\TransformEngine.js
```js
// src/transform/TransformEngine.js - Design Pattern: Strategy Pattern
const logger = require('../utils/Logger');
const fs = require('fs');
const path = require('path');

/**
 * TransformEngine Ã¡p dá»¥ng Strategy Pattern
 * Má»—i transformer lÃ  má»™t strategy Ä‘á»ƒ transform data
 */
class TransformEngine {
  constructor() {
    this.transformers = new Map();
    this.loadAllTransformers();
  }

  /**
   * Load táº¥t cáº£ transformers tá»« thÆ° má»¥c transformers/
   */
  loadAllTransformers() {
    const transformersDir = path.join(__dirname, 'transformers');
    const transformerFiles = fs.readdirSync(transformersDir)
      .filter(f => f.endsWith('Transformer.js'));

    for (const file of transformerFiles) {
      try {
        const TransformerClass = require(path.join(transformersDir, file));
        const transformerInstance = new TransformerClass();
        const fieldName = transformerInstance.getFieldName();
        
        this.transformers.set(fieldName, transformerInstance);
        console.log(`âœ“ Loaded transformer: ${file} for field: ${fieldName}`);
      } catch (error) {
        console.error(`âœ— Failed to load transformer: ${file}`, error.message);
      }
    }

    logger.info(`Loaded ${this.transformers.size} transformers`);
  }

  /**
   * Transform má»™t record dá»±a trÃªn validation errors
   * @param {object} record - Record cáº§n transform
   * @param {object} validationResult - Káº¿t quáº£ validation tá»« RuleEngine
   * @returns {object} Transformed record vÃ  metadata
   */
  transformRecord(record, validationResult) {
    const transformed = { ...record };
    const transformLog = [];

    if (!validationResult || validationResult.isValid) {
      return {
        record: transformed,
        transformed: false,
        log: []
      };
    }

    // Chá»‰ transform cÃ¡c fields cÃ³ lá»—i cÃ³ thá»ƒ fix
    const fixableFields = new Set();
    validationResult.fixableErrors.forEach(error => {
      fixableFields.add(error.field);
    });

    // Apply transformers cho tá»«ng field
    for (const fieldName of fixableFields) {
      if (this.transformers.has(fieldName)) {
        const transformer = this.transformers.get(fieldName);
        const originalValue = record[fieldName];
        
        // Láº¥y errors cá»§a field nÃ y
        const fieldErrors = validationResult.errors.filter(e => e.field === fieldName);
        
        // Transform
        const transformedValue = transformer.transform(
          originalValue,
          record,
          fieldErrors
        );

        if (transformedValue !== originalValue) {
          transformed[fieldName] = transformedValue;
          
          const log = transformer.logTransform(originalValue, transformedValue);
          transformLog.push(log);
        }
      }
    }

    return {
      record: transformed,
      transformed: transformLog.length > 0,
      log: transformLog,
      fieldsTransformed: Array.from(fixableFields)
    };
  }

  /**
   * Transform má»™t batch records
   */
  async transformBatch(records, validationResults) {
    await logger.startPhase('TRANSFORM - Applying Transformations');

    const results = {
      totalRecords: records.length,
      transformedRecords: 0,
      skippedRecords: 0,
      records: [],
      logs: []
    };

    for (let i = 0; i < records.length; i++) {
      const record = records[i];
      const validationResult = validationResults.results[i];

      const transformResult = this.transformRecord(record, validationResult);
      
      results.records.push(transformResult.record);
      
      if (transformResult.transformed) {
        results.transformedRecords++;
        results.logs.push({
          recordIndex: i,
          originalRecord: record,
          transformedRecord: transformResult.record,
          transformLog: transformResult.log
        });
      } else {
        results.skippedRecords++;
      }
    }

    await logger.endPhase('TRANSFORM - Applying Transformations', {
      totalRecords: results.totalRecords,
      transformedRecords: results.transformedRecords,
      skippedRecords: results.skippedRecords
    });

    // Log chi tiáº¿t
    if (results.logs.length > 0) {
      await logger.info('Transform details', {
        sampleTransforms: results.logs.slice(0, 5)
      });
    }

    return results;
  }

  /**
   * Transform vá»›i custom strategy
   */
  transformWithStrategy(record, fieldName, strategyFn) {
    const transformed = { ...record };
    const originalValue = record[fieldName];
    
    transformed[fieldName] = strategyFn(originalValue, record);
    
    return {
      record: transformed,
      changed: transformed[fieldName] !== originalValue
    };
  }

  /**
   * ThÃªm transformer má»›i dynamically
   */
  addTransformer(fieldName, transformerInstance) {
    this.transformers.set(fieldName, transformerInstance);
    logger.info(`Added transformer for field: ${fieldName}`);
  }

  /**
   * Láº¥y transformer cho field
   */
  getTransformer(fieldName) {
    return this.transformers.get(fieldName);
  }

  /**
   * Kiá»ƒm tra cÃ³ transformer khÃ´ng
   */
  hasTransformer(fieldName) {
    return this.transformers.has(fieldName);
  }

  /**
   * Láº¥y danh sÃ¡ch fields cÃ³ transformer
   */
  getAvailableTransformers() {
    return Array.from(this.transformers.keys());
  }

  /**
   * Apply multiple transforms theo thá»© tá»±
   */
  applyTransformPipeline(record, pipeline) {
    let transformed = { ...record };

    for (const fieldName of pipeline) {
      if (this.transformers.has(fieldName)) {
        const transformer = this.transformers.get(fieldName);
        const value = transformed[fieldName];
        transformed[fieldName] = transformer.transform(value, transformed);
      }
    }

    return transformed;
  }

  /**
   * Transform vá»›i conditions
   */
  transformConditional(record, conditions) {
    const transformed = { ...record };

    for (const [fieldName, condition] of Object.entries(conditions)) {
      if (condition(record) && this.transformers.has(fieldName)) {
        const transformer = this.transformers.get(fieldName);
        transformed[fieldName] = transformer.transform(
          record[fieldName],
          record
        );
      }
    }

    return transformed;
  }
}

module.exports = TransformEngine;
```

### src\transform\TransformService.js
```js

```

### src\transform\transformers\EmailTransformer.js
```js
// src/transform/transformers/EmailTransformer.js - Transform Email
class EmailTransformer {
  constructor() {
    this.fieldName = 'email';
  }

  /**
   * Transform email theo cÃ¡c quy táº¯c:
   * 1. Chuyá»ƒn táº¥t cáº£ thÃ nh lowercase
   * 2. XÃ³a khoáº£ng tráº¯ng
   * 3. Trim Ä‘áº§u cuá»‘i
   */
  transform(value, record, validationErrors = []) {
    if (!value) return null;

    let transformed = value.toString();

    // Step 1: Trim
    transformed = transformed.trim();

    // Step 2: XÃ³a táº¥t cáº£ khoáº£ng tráº¯ng
    transformed = transformed.replace(/\s+/g, '');

    // Step 3: Chuyá»ƒn thÃ nh lowercase
    transformed = transformed.toLowerCase();

    // Step 4: Fix common typos
    transformed = this.fixCommonTypos(transformed);

    return transformed;
  }

  /**
   * Sá»­a cÃ¡c lá»—i typo phá»• biáº¿n
   */
  fixCommonTypos(email) {
    // Replace common typos
    const typos = {
      'gmial.com': 'gmail.com',
      'gmai.com': 'gmail.com',
      'yahooo.com': 'yahoo.com',
      'yaho.com': 'yahoo.com',
      'hotmial.com': 'hotmail.com',
      'outloook.com': 'outlook.com'
    };

    let fixed = email;
    for (const [typo, correct] of Object.entries(typos)) {
      if (fixed.includes(typo)) {
        fixed = fixed.replace(typo, correct);
      }
    }

    return fixed;
  }

  canTransform(value, validationErrors) {
    return validationErrors && validationErrors.some(e => e.canFix);
  }

  getFieldName() {
    return this.fieldName;
  }

  transformBatch(records, errorsByRecord) {
    return records.map((record, index) => {
      const errors = errorsByRecord[index] || [];
      const transformed = { ...record };
      
      if (record[this.fieldName]) {
        transformed[this.fieldName] = this.transform(
          record[this.fieldName],
          record,
          errors
        );
      }
      
      return transformed;
    });
  }

  logTransform(originalValue, transformedValue) {
    return {
      field: this.fieldName,
      original: originalValue,
      transformed: transformedValue,
      action: 'lowercase_and_normalize'
    };
  }
}

module.exports = EmailTransformer;
```

### src\transform\transformers\HoTenTransformer.js
```js
// src/transform/transformers/HoTenTransformer.js - Transform há» tÃªn
/**
 * Design Pattern: Strategy Pattern
 * Má»—i transformer lÃ  má»™t strategy khÃ¡c nhau Ä‘á»ƒ transform data
 */
class HoTenTransformer {
  constructor() {
    this.fieldName = 'ho_ten';
  }

  /**
   * Transform há» tÃªn theo cÃ¡c quy táº¯c:
   * 1. Trim khoáº£ng tráº¯ng thá»«a
   * 2. Chuáº©n hÃ³a chá»¯ cÃ¡i Ä‘áº§u má»—i tá»« viáº¿t hoa
   * 3. Xá»­ lÃ½ viáº¿t táº¯t
   * 4. Chuyá»ƒn thÃ nh tiáº¿ng Viá»‡t cÃ³ dáº¥u chuáº©n
   */
  transform(value, record, validationErrors = []) {
    if (!value) return null;

    let transformed = value.toString().trim();

    // Step 1: XÃ³a khoáº£ng tráº¯ng thá»«a
    transformed = this.removeExtraSpaces(transformed);

    // Step 2: Chuáº©n hÃ³a viáº¿t hoa chá»¯ cÃ¡i Ä‘áº§u
    transformed = this.capitalizeWords(transformed);

    // Step 3: Xá»­ lÃ½ viáº¿t táº¯t (le t nga -> LÃª Thá»‹ Nga)
    transformed = this.expandAbbreviations(transformed);

    // Step 4: Chuáº©n hÃ³a tiáº¿ng Viá»‡t (náº¿u cÃ³ lá»—i vá» encoding)
    transformed = this.normalizeVietnamese(transformed);

    // Step 5: Xá»­ lÃ½ trÆ°á»ng há»£p chá»‰ cÃ³ 1 tá»«
    if (this.shouldAddDefaultSurname(transformed, validationErrors)) {
      transformed = this.addDefaultSurname(transformed);
    }

    return transformed;
  }

  /**
   * XÃ³a khoáº£ng tráº¯ng thá»«a
   */
  removeExtraSpaces(text) {
    return text.replace(/\s+/g, ' ').trim();
  }

  /**
   * Viáº¿t hoa chá»¯ cÃ¡i Ä‘áº§u má»—i tá»«
   */
  capitalizeWords(text) {
    return text
      .split(' ')
      .map(word => {
        if (word.length === 0) return word;
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      })
      .join(' ');
  }

  /**
   * Má»Ÿ rá»™ng viáº¿t táº¯t tiáº¿ng Viá»‡t
   * VD: "le t nga" -> "LÃª Thá»‹ Nga"
   */
  expandAbbreviations(text) {
    const words = text.split(' ');
    const expanded = [];

    // Map cÃ¡c viáº¿t táº¯t phá»• biáº¿n
    const commonAbbreviations = {
      'v': 'VÄƒn',
      't': 'Thá»‹',
      'h': 'Há»¯u',
      'd': 'Äá»©c',
      'k': 'Kim',
      'm': 'Minh',
      'n': 'Ngá»c'
    };

    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      
      // Náº¿u lÃ  viáº¿t táº¯t (1 chá»¯ cÃ¡i) vÃ  á»Ÿ giá»¯a/cuá»‘i
      if (word.length === 1 && i > 0) {
        const abbrev = word.toLowerCase();
        if (commonAbbreviations[abbrev]) {
          expanded.push(commonAbbreviations[abbrev]);
          continue;
        }
      }
      
      expanded.push(word);
    }

    return expanded.join(' ');
  }

  /**
   * Chuáº©n hÃ³a tiáº¿ng Viá»‡t (xá»­ lÃ½ encoding sai)
   */
  normalizeVietnamese(text) {
    // Xá»­ lÃ½ cÃ¡c trÆ°á»ng há»£p encoding sai phá»• biáº¿n
    const replacements = {
      'ÃƒÂ¡': 'Ã¡',
      'Ãƒ ': 'Ã ',
      'Ã¡ÂºÂ¡': 'áº¡',
      'Ã¡ÂºÂ£': 'áº£',
      'ÃƒÂ£': 'Ã£',
      'Ã„': 'Ä‘',
      // ... thÃªm cÃ¡c mapping khÃ¡c náº¿u cáº§n
    };

    let normalized = text;
    for (const [wrong, correct] of Object.entries(replacements)) {
      normalized = normalized.replace(new RegExp(wrong, 'g'), correct);
    }

    return normalized;
  }

  /**
   * Kiá»ƒm tra xem cÃ³ cáº§n thÃªm há» máº·c Ä‘á»‹nh khÃ´ng
   */
  shouldAddDefaultSurname(text, validationErrors) {
    const words = text.split(' ');
    return words.length === 1 && 
           validationErrors.some(e => e.message.includes('Ã­t nháº¥t 2 tá»«'));
  }

  /**
   * ThÃªm há» máº·c Ä‘á»‹nh náº¿u chá»‰ cÃ³ tÃªn
   */
  addDefaultSurname(text) {
    // ThÃªm "KhÃ´ng rÃµ" vÃ o trÆ°á»›c
    return `KhÃ´ng RÃµ ${text}`;
  }

  /**
   * Kiá»ƒm tra xem transformation cÃ³ thÃ nh cÃ´ng khÃ´ng
   */
  canTransform(value, validationErrors) {
    // Chá»‰ transform náº¿u cÃ³ lá»—i cÃ³ thá»ƒ fix
    return validationErrors && validationErrors.some(e => e.canFix);
  }

  /**
   * Láº¥y field name
   */
  getFieldName() {
    return this.fieldName;
  }

  /**
   * Transform batch
   */
  transformBatch(records, errorsByRecord) {
    return records.map((record, index) => {
      const errors = errorsByRecord[index] || [];
      const transformed = { ...record };
      
      if (record[this.fieldName]) {
        transformed[this.fieldName] = this.transform(
          record[this.fieldName],
          record,
          errors
        );
      }
      
      return transformed;
    });
  }

  /**
   * Logging transform action
   */
  logTransform(originalValue, transformedValue) {
    return {
      field: this.fieldName,
      original: originalValue,
      transformed: transformedValue,
      action: 'capitalize_and_normalize'
    };
  }
}

module.exports = HoTenTransformer;
```

### src\transform\transformers\NgayThangTransformer.js
```js
// src/transform/transformers/NgayThangTransformer.js
const moment = require('moment');

class NgayThangTransformer {
  constructor() {
    // Sáº½ Ã¡p dá»¥ng cho táº¥t cáº£ cÃ¡c trÆ°á»ng cÃ³ tÃªn lÃ  'ngay_sinh', 'ngay_dat', etc.
    // NhÆ°ng Ä‘á»ƒ Ä‘Æ¡n giáº£n, ta chá»‰ Ä‘á»‹nh má»™t field chÃ­nh. TransformEngine sáº½ tÃ¬m Ä‘Ãºng transformer.
    this.fieldName = 'ngay_sinh'; 
  }

  transform(value, record, validationErrors = []) {
    if (!value) return null;

    // Thá»­ parse date vá»›i cÃ¡c Ä‘á»‹nh dáº¡ng phá»• biáº¿n
    const date = moment(value);
    
    if (date.isValid()) {
      // Tráº£ vá» Ä‘á»‹nh dáº¡ng chuáº©n YYYY-MM-DD
      return date.format('YYYY-MM-DD');
    }

    // Náº¿u khÃ´ng parse Ä‘Æ°á»£c, tráº£ vá» giÃ¡ trá»‹ gá»‘c Ä‘á»ƒ khÃ´ng lÃ m máº¥t dá»¯ liá»‡u
    return value;
  }

  getFieldName() {
    return this.fieldName;
  }

  logTransform(originalValue, transformedValue) {
    return {
      field: this.fieldName, // Field thá»±c táº¿ cÃ³ thá»ƒ khÃ¡c, nhÆ°ng log nÃ y lÃ  Ä‘á»§
      original: originalValue,
      transformed: transformedValue,
      action: 'format_date_to_yyyy_mm_dd'
    };
  }
}

module.exports = NgayThangTransformer;
```

### src\transform\transformers\TrangThaiTransformer.js
```js
// src/transform/transformers/TrangThaiTransformer.js
class TrangThaiTransformer {
  constructor() {
    this.fieldName = 'trang_thai';
  }

  transform(value, record, validationErrors = []) {
    if (!value) return value;

    // Láº¥y suggestion tá»« lá»—i validation náº¿u cÃ³ (Module TrangThai.rule.js Ä‘Ã£ gá»£i Ã½ sá»­a lá»—i chÃ­nh táº£)
    const error = validationErrors.find(e => e.suggestion && e.field === this.fieldName);
    if (error && error.suggestion) {
        // Giáº£ sá»­ suggestion dáº¡ng: "CÃ³ thá»ƒ lÃ : ÄÃ£ giao" hoáº·c "Chuyá»ƒn thÃ nh: ÄÃ£ giao"
        const match = error.suggestion.split(': ');
        if (match.length > 1) {
            return match[1].trim();
        }
    }

    // Máº·c Ä‘á»‹nh viáº¿t hoa chá»¯ cÃ¡i Ä‘áº§u
    return value.charAt(0).toUpperCase() + value.slice(1);
  }

  getFieldName() {
    return this.fieldName;
  }

  logTransform(originalValue, transformedValue) {
    return {
      field: this.fieldName,
      original: originalValue,
      transformed: transformedValue,
      action: 'normalize_status'
    };
  }
}

module.exports = TrangThaiTransformer;
```

### src\utils\ErrorLogger.js
```js

```

### src\utils\helpers.js
```js

```

### src\utils\Logger.js
```js
// src/utils/Logger.js - System cho log.txt vÃ  console
const fs = require('fs-extra');
const path = require('path');
const moment = require('moment');

class Logger {
  constructor() {
    this.logDir = path.join(__dirname, '../../logs');
    this.logFile = path.join(this.logDir, 'log.log');
    this.errorLogFile = path.join(this.logDir, 'errorLog.log');
    this.initLogFiles();
  }

  async initLogFiles() {
    await fs.ensureDir(this.logDir);
    
    // Create log files if they don't exist
    if (!await fs.pathExists(this.logFile)) {
      await fs.writeFile(this.logFile, '');
    }
    if (!await fs.pathExists(this.errorLogFile)) {
      await fs.writeFile(this.errorLogFile, '');
    }
  }

  getTimestamp() {
    return moment().format('YYYY-MM-DD HH:mm:ss');
  }

  formatMessage(level, message, data = null) {
    let logMessage = `[${this.getTimestamp()}] [${level}] ${message}`;
    if (data) {
      logMessage += `\n${JSON.stringify(data, null, 2)}`;
    }
    return logMessage;
  }

  // Log thÃ´ng tin chung (console + log.txt)
  async info(message, data = null) {
    const logMessage = this.formatMessage('INFO', message, data);
    console.log(`â„¹ï¸  ${message}`);
    if (data) console.log(data);
    
    await fs.appendFile(this.logFile, logMessage + '\n\n');
  }

  // Log cáº£nh bÃ¡o
  async warn(message, data = null) {
    const logMessage = this.formatMessage('WARN', message, data);
    console.warn(`âš ï¸  ${message}`);
    if (data) console.warn(data);
    
    await fs.appendFile(this.logFile, logMessage + '\n\n');
  }

  // Log lá»—i (console + errorLog.txt + log.txt)
  async error(message, error = null, data = null) {
    const errorDetails = error ? {
      message: error.message,
      stack: error.stack,
      ...data
    } : data;

    const logMessage = this.formatMessage('ERROR', message, errorDetails);
    console.error(`âŒ ${message}`);
    if (error) console.error(error);
    
    // Ghi vÃ o cáº£ 2 file
    await fs.appendFile(this.errorLogFile, logMessage + '\n\n');
    await fs.appendFile(this.logFile, logMessage + '\n\n');
  }

  // Log thÃ nh cÃ´ng
  async success(message, data = null) {
    const logMessage = this.formatMessage('SUCCESS', message, data);
    console.log(`âœ… ${message}`);
    if (data) console.log(data);
    
    await fs.appendFile(this.logFile, logMessage + '\n\n');
  }

  // Log debug
  async debug(message, data = null) {
    const logMessage = this.formatMessage('DEBUG', message, data);
    console.log(`ğŸ› ${message}`);
    if (data) console.log(data);
    
    await fs.appendFile(this.logFile, logMessage + '\n\n');
  }

  // Log báº¯t Ä‘áº§u má»™t phase
  async startPhase(phaseName) {
    const separator = '='.repeat(80);
    const message = `\n${separator}\n  ${phaseName} STARTED\n${separator}\n`;
    console.log(message);
    await fs.appendFile(this.logFile, message);
  }

  // Log káº¿t thÃºc má»™t phase
  async endPhase(phaseName, stats = null) {
    const separator = '='.repeat(80);
    let message = `\n${separator}\n  ${phaseName} COMPLETED`;
    if (stats) {
      message += `\n  Stats: ${JSON.stringify(stats)}`;
    }
    message += `\n${separator}\n\n`;
    
    console.log(message);
    await fs.appendFile(this.logFile, message);
  }

  // Log thá»‘ng kÃª
  async stats(title, statistics) {
    const message = this.formatMessage('STATS', title, statistics);
    console.log(`ğŸ“Š ${title}:`, statistics);
    await fs.appendFile(this.logFile, message + '\n\n');
  }

  // Clear logs (cho testing)
  async clearLogs() {
    await fs.writeFile(this.logFile, '');
    await fs.writeFile(this.errorLogFile, '');
    console.log('ğŸ—‘ï¸  Logs cleared');
  }
}

module.exports = new Logger();
```

### src\validation\RuleEngine.js
```js
// src/validation/RuleEngine.js - Design Pattern: Chain of Responsibility
const logger = require('../utils/Logger');
const fs = require('fs');
const path = require('path');

/**
 * RuleEngine Ã¡p dá»¥ng Chain of Responsibility Pattern
 * Má»—i rule Ä‘Æ°á»£c xá»­ lÃ½ tuáº§n tá»±, náº¿u fail thÃ¬ dá»«ng hoáº·c tiáº¿p tá»¥c tÃ¹y config
 */
class RuleEngine {
  constructor() {
    this.rules = new Map();
    this.loadAllRules();
  }

  /**
   * Load táº¥t cáº£ cÃ¡c rule files tá»« thÆ° má»¥c rules/
   */
  loadAllRules() {
    const rulesDir = path.join(__dirname, 'rules');
    const ruleFiles = fs.readdirSync(rulesDir).filter(f => f.endsWith('.rule.js'));

    for (const file of ruleFiles) {
      try {
        const RuleClass = require(path.join(rulesDir, file));
        const ruleInstance = new RuleClass();
        const fieldName = ruleInstance.getFieldName();
        
        this.rules.set(fieldName, ruleInstance);
        console.log(`âœ“ Loaded rule: ${file} for field: ${fieldName}`);
      } catch (error) {
        console.error(`âœ— Failed to load rule: ${file}`, error.message);
      }
    }

    logger.info(`Loaded ${this.rules.size} validation rules`);
  }

  /**
   * Validate má»™t record vá»›i táº¥t cáº£ cÃ¡c rules tÆ°Æ¡ng á»©ng
   * @param {object} record - Record cáº§n validate
   * @param {array} fieldsToValidate - Danh sÃ¡ch fields cáº§n validate
   * @returns {object} Káº¿t quáº£ validation
   */
  validateRecord(record, fieldsToValidate = null) {
    const results = {
      isValid: true,
      canFix: true,
      errors: [],
      fixableErrors: [],
      unfixableErrors: [],
      fieldsValidated: []
    };

    // Náº¿u khÃ´ng chá»‰ Ä‘á»‹nh fields, validate táº¥t cáº£
    const fields = fieldsToValidate || Object.keys(record);

    for (const field of fields) {
      if (this.rules.has(field)) {
        const rule = this.rules.get(field);
        const value = record[field];
        
        const validationResult = rule.validate(value, record);
        
        results.fieldsValidated.push(field);

        if (!validationResult.isValid) {
          results.isValid = false;
          results.errors.push(...validationResult.errors);

          if (validationResult.canFix) {
            results.fixableErrors.push(...validationResult.errors);
          } else {
            results.unfixableErrors.push(...validationResult.errors);
            results.canFix = false;
          }
        }
      }
    }

    return results;
  }

  /**
   * Validate má»™t batch records
   */
  validateBatch(records, fieldsToValidate = null) {
    const batchResults = {
      totalRecords: records.length,
      validRecords: 0,
      invalidRecords: 0,
      fixableRecords: 0,
      unfixableRecords: 0,
      results: []
    };

    for (const record of records) {
      const result = this.validateRecord(record, fieldsToValidate);
      result.record = record;
      batchResults.results.push(result);

      if (result.isValid) {
        batchResults.validRecords++;
      } else {
        batchResults.invalidRecords++;
        if (result.canFix) {
          batchResults.fixableRecords++;
        } else {
          batchResults.unfixableRecords++;
        }
      }
    }

    return batchResults;
  }

  /**
   * Láº¥y rule cho má»™t field
   */
  getRule(fieldName) {
    return this.rules.get(fieldName);
  }

  /**
   * Kiá»ƒm tra xem cÃ³ rule cho field khÃ´ng
   */
  hasRule(fieldName) {
    return this.rules.has(fieldName);
  }

  /**
   * ThÃªm rule má»›i dynamically
   */
  addRule(fieldName, ruleInstance) {
    this.rules.set(fieldName, ruleInstance);
    logger.info(`Added new rule for field: ${fieldName}`);
  }

  /**
   * XÃ³a rule
   */
  removeRule(fieldName) {
    this.rules.delete(fieldName);
    logger.info(`Removed rule for field: ${fieldName}`);
  }

  /**
   * Láº¥y danh sÃ¡ch táº¥t cáº£ cÃ¡c fields cÃ³ rule
   */
  getAvailableRules() {
    return Array.from(this.rules.keys());
  }

  /**
   * Validate vá»›i custom rule chain
   */
  async validateWithChain(record, ruleChain) {
    const results = {
      isValid: true,
      errors: [],
      stoppedAt: null
    };

    for (let i = 0; i < ruleChain.length; i++) {
      const fieldName = ruleChain[i];
      
      if (!this.rules.has(fieldName)) {
        await logger.warn(`No rule found for field: ${fieldName}`);
        continue;
      }

      const rule = this.rules.get(fieldName);
      const value = record[fieldName];
      const validationResult = rule.validate(value, record);

      if (!validationResult.isValid) {
        results.isValid = false;
        results.errors.push(...validationResult.errors);
        
        // Stop chain náº¿u unfixable
        if (!validationResult.canFix) {
          results.stoppedAt = fieldName;
          break;
        }
      }
    }

    return results;
  }
}

module.exports = RuleEngine;
```

### src\validation\ValidationService.js
```js

```

### src\validation\rules\DonGia.rule.js
```js
// src/validation/rules/DonGia.rule.js
const { LIMITS, ERROR_CODES } = require('../../../config/constants');

class DonGiaRule {
  constructor() {
    this.fieldName = 'don_gia';
  }

  validate(value, record) {
    const errors = [];
    if (value === null || value === undefined) {
      return { isValid: true, errors: [] }; // Cho phÃ©p null
    }

    const price = parseFloat(value);
    if (isNaN(price)) {
      errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'ÄÆ¡n giÃ¡ pháº£i lÃ  má»™t con sá»‘.',
        value,
        canFix: false,
      });
    }

    if (price < LIMITS.MIN_PRICE || price > LIMITS.MAX_PRICE) {
      errors.push({
        code: ERROR_CODES.OUT_OF_RANGE,
        field: this.fieldName,
        message: `ÄÆ¡n giÃ¡ pháº£i náº±m trong khoáº£ng tá»« ${LIMITS.MIN_PRICE} Ä‘áº¿n ${LIMITS.MAX_PRICE}.`,
        value,
        canFix: false,
      });
    }

    return {
      isValid: errors.length === 0,
      canFix: false,
      errors: errors,
    };
  }

  getFieldName() {
    return this.fieldName;
  }
}

module.exports = DonGiaRule;
```

### src\validation\rules\Email.rule.js
```js
// src/validation/rules/Email.rule.js - Validation cho Email
const { REGEX, LIMITS, ERROR_CODES } = require('../../../config/constants');

class EmailRule {
  constructor() {
    this.fieldName = 'email';
    this.errors = [];
  }

  validate(value, record) {
    this.errors = [];
    let canFix = true;

    // Rule 1: KhÃ´ng Ä‘Æ°á»£c null
    if (!value || value.toString().trim() === '') {
      this.errors.push({
        code: ERROR_CODES.NULL_VALUE,
        field: this.fieldName,
        message: 'Email khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng',
        value: value,
        canFix: false
      });
      return {
        isValid: false,
        canFix: false,
        errors: this.errors,
        value: value
      };
    }

    value = value.toString().trim().toLowerCase();

    // Rule 2: Kiá»ƒm tra format email vá»›i Regex
    if (!REGEX.EMAIL.test(value)) {
      this.errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Email khÃ´ng Ä‘Ãºng Ä‘á»‹nh dáº¡ng',
        value: value,
        canFix: false
      });
      canFix = false;
    }

    // Rule 3: Äá»™ dÃ i khÃ´ng vÆ°á»£t quÃ¡
    if (value.length > LIMITS.MAX_EMAIL_LENGTH) {
      this.errors.push({
        code: ERROR_CODES.OUT_OF_RANGE,
        field: this.fieldName,
        message: `Email khÃ´ng Ä‘Æ°á»£c vÆ°á»£t quÃ¡ ${LIMITS.MAX_EMAIL_LENGTH} kÃ½ tá»±`,
        value: value,
        canFix: false
      });
      canFix = false;
    }

    // Rule 4: KhÃ´ng chá»©a khoáº£ng tráº¯ng (cÃ³ thá»ƒ fix)
    if (/\s/.test(value)) {
      this.errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Email khÃ´ng Ä‘Æ°á»£c chá»©a khoáº£ng tráº¯ng',
        value: value,
        canFix: true,
        suggestion: 'XÃ³a táº¥t cáº£ khoáº£ng tráº¯ng'
      });
    }

    // Rule 5: Pháº£i cÃ³ @ vÃ  domain há»£p lá»‡
    if (value.includes('@')) {
      const parts = value.split('@');
      if (parts.length !== 2 || parts[0].length === 0 || parts[1].length === 0) {
        this.errors.push({
          code: ERROR_CODES.INVALID_FORMAT,
          field: this.fieldName,
          message: 'Email thiáº¿u pháº§n trÆ°á»›c hoáº·c sau @',
          value: value,
          canFix: false
        });
        canFix = false;
      }

      // Kiá»ƒm tra domain
      if (parts[1] && !parts[1].includes('.')) {
        this.errors.push({
          code: ERROR_CODES.INVALID_FORMAT,
          field: this.fieldName,
          message: 'Domain email khÃ´ng há»£p lá»‡ (thiáº¿u .)',
          value: value,
          canFix: false
        });
        canFix = false;
      }
    }

    // Rule 6: KhÃ´ng Ä‘Æ°á»£c cÃ³ kÃ½ tá»± Ä‘áº·c biá»‡t khÃ´ng há»£p lá»‡
    const invalidChars = /[<>()[\]\\,;:"]/.test(value);
    if (invalidChars) {
      this.errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Email chá»©a kÃ½ tá»± Ä‘áº·c biá»‡t khÃ´ng há»£p lá»‡',
        value: value,
        canFix: false
      });
      canFix = false;
    }

    // Rule 7: Email pháº£i lÃ  chá»¯ thÆ°á»ng (cÃ³ thá»ƒ fix)
    if (value !== value.toLowerCase()) {
      this.errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Email nÃªn Ä‘Æ°á»£c viáº¿t thÆ°á»ng',
        value: value,
        canFix: true,
        suggestion: 'Chuyá»ƒn táº¥t cáº£ thÃ nh chá»¯ thÆ°á»ng'
      });
    }

    const isValid = this.errors.length === 0;

    return {
      isValid,
      canFix: canFix && this.errors.length > 0,
      errors: this.errors,
      value: value,
      needsTransform: this.errors.some(e => e.canFix)
    };
  }

  getErrors() {
    return this.errors;
  }

  getFieldName() {
    return this.fieldName;
  }
}

module.exports = EmailRule;
```

### src\validation\rules\HoTen.rule.js
```js
// src/validation/rules/HoTen.rule.js - Validation cho trÆ°á»ng Há» TÃªn
const { LIMITS, ERROR_CODES } = require('../../../config/constants');

/**
 * Design Pattern: Chain of Responsibility
 * Má»—i rule lÃ  má»™t handler trong chain
 */
class HoTenRule {
  constructor() {
    this.fieldName = 'ho_ten';
    this.errors = [];
  }

  /**
   * Validate há» tÃªn
   * @returns {object} { isValid, canFix, errors, value }
   */
  validate(value, record) {
    this.errors = [];
    let canFix = true;

    // Rule 1: KhÃ´ng Ä‘Æ°á»£c null hoáº·c rá»—ng
    if (!value || value.toString().trim() === '') {
      this.errors.push({
        code: ERROR_CODES.NULL_VALUE,
        field: this.fieldName,
        message: 'Há» tÃªn khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng',
        value: value,
        canFix: false
      });
      return {
        isValid: false,
        canFix: false,
        errors: this.errors,
        value: value
      };
    }

    value = value.toString().trim();

    // Rule 2: KhÃ´ng Ä‘Æ°á»£c chá»©a sá»‘
    const containsNumber = /\d/.test(value);
    if (containsNumber) {
      this.errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Há» tÃªn khÃ´ng Ä‘Æ°á»£c chá»©a sá»‘',
        value: value,
        canFix: false
      });
      canFix = false;
    }

    // Rule 3: KhÃ´ng Ä‘Æ°á»£c chá»©a kÃ½ tá»± Ä‘áº·c biá»‡t (trá»« khoáº£ng tráº¯ng)
    const specialCharsRegex = /[!@#$%^&*()_+=\[\]{};':"\\|,.<>?]/;
    if (specialCharsRegex.test(value)) {
      this.errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Há» tÃªn khÃ´ng Ä‘Æ°á»£c chá»©a kÃ½ tá»± Ä‘áº·c biá»‡t',
        value: value,
        canFix: false
      });
      canFix = false;
    }

    // Rule 4: Äá»™ dÃ i khÃ´ng vÆ°á»£t quÃ¡ giá»›i háº¡n
    if (value.length > LIMITS.MAX_NAME_LENGTH) {
      this.errors.push({
        code: ERROR_CODES.OUT_OF_RANGE,
        field: this.fieldName,
        message: `Há» tÃªn khÃ´ng Ä‘Æ°á»£c vÆ°á»£t quÃ¡ ${LIMITS.MAX_NAME_LENGTH} kÃ½ tá»±`,
        value: value,
        canFix: false
      });
      canFix = false;
    }

    // Rule 5: Pháº£i cÃ³ Ã­t nháº¥t 2 tá»« (cÃ³ thá»ƒ fix Ä‘Æ°á»£c)
    const words = value.split(/\s+/).filter(w => w.length > 0);
    if (words.length < 2) {
      this.errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Há» tÃªn pháº£i cÃ³ Ã­t nháº¥t 2 tá»« (há» vÃ  tÃªn)',
        value: value,
        canFix: true,
        suggestion: 'ThÃªm "KhÃ´ng rÃµ" vÃ o cuá»‘i náº¿u chá»‰ cÃ³ 1 tá»«'
      });
      // Váº«n cÃ³ thá»ƒ fix Ä‘Æ°á»£c báº±ng cÃ¡ch thÃªm má»™t tá»« máº·c Ä‘á»‹nh
    }

    // Rule 6: KhÃ´ng Ä‘Æ°á»£c viáº¿t táº¯t khÃ´ng Ä‘Ãºng quy táº¯c (cÃ³ thá»ƒ fix)
    // VD: "le t nga" -> cÃ³ thá»ƒ fix thÃ nh "LÃª Thá»‹ Nga"
    const hasInvalidAbbreviation = /\b[a-z]\s/.test(value.toLowerCase());
    if (hasInvalidAbbreviation) {
      this.errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Há» tÃªn cÃ³ viáº¿t táº¯t khÃ´ng Ä‘Ãºng quy táº¯c',
        value: value,
        canFix: true,
        suggestion: 'Chuáº©n hÃ³a chá»¯ cÃ¡i Ä‘áº§u tiÃªn cá»§a má»—i tá»« viáº¿t hoa'
      });
    }

    // Rule 7: KhÃ´ng Ä‘Æ°á»£c viáº¿t táº¯t quÃ¡ 20 kÃ½ tá»±
    if (value.length > 20) {
      const shortWords = words.filter(w => w.length === 1);
      if (shortWords.length > 0) {
        this.errors.push({
          code: ERROR_CODES.INVALID_FORMAT,
          field: this.fieldName,
          message: 'Há» tÃªn quÃ¡ dÃ i vÃ  cÃ³ viáº¿t táº¯t',
          value: value,
          canFix: false
        });
        canFix = false;
      }
    }

    // Rule 8: Chá»¯ cÃ¡i Ä‘áº§u má»—i tá»« pháº£i viáº¿t hoa (cÃ³ thá»ƒ fix)
    const hasInvalidCapitalization = words.some(word => {
      return word[0] !== word[0].toUpperCase();
    });
    
    if (hasInvalidCapitalization) {
      this.errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Chá»¯ cÃ¡i Ä‘áº§u cá»§a má»—i tá»« cáº§n viáº¿t hoa',
        value: value,
        canFix: true,
        suggestion: 'Chuyá»ƒn chá»¯ cÃ¡i Ä‘áº§u má»—i tá»« thÃ nh chá»¯ hoa'
      });
    }

    const isValid = this.errors.length === 0;

    return {
      isValid,
      canFix: canFix && this.errors.length > 0,
      errors: this.errors,
      value: value,
      needsTransform: this.errors.some(e => e.canFix)
    };
  }

  /**
   * Láº¥y danh sÃ¡ch lá»—i
   */
  getErrors() {
    return this.errors;
  }

  /**
   * Láº¥y tÃªn field
   */
  getFieldName() {
    return this.fieldName;
  }

  /**
   * Kiá»ƒm tra xem cÃ³ thá»ƒ tá»± Ä‘á»™ng fix khÃ´ng
   */
  isAutoFixable(validationResult) {
    return validationResult.canFix && 
           validationResult.errors.every(e => e.canFix);
  }
}

module.exports = HoTenRule;
```

### src\validation\rules\NgaySinh.rule.js
```js
// src/validation/rules/NgaySinh.rule.js - Validation cho NgÃ y Sinh
const { LIMITS, ERROR_CODES } = require('../../../config/constants');
const moment = require('moment');

class NgaySinhRule {
  constructor() {
    this.fieldName = 'ngay_sinh';
    this.errors = [];
  }

  validate(value, record) {
    this.errors = [];
    let canFix = true;

    // Rule 1: KhÃ´ng Ä‘Æ°á»£c null
    if (!value) {
      this.errors.push({
        code: ERROR_CODES.NULL_VALUE,
        field: this.fieldName,
        message: 'NgÃ y sinh khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng',
        value: value,
        canFix: false
      });
      return {
        isValid: false,
        canFix: false,
        errors: this.errors,
        value: value
      };
    }

    // Parse date
    let dateValue;
    try {
      dateValue = moment(value);
      if (!dateValue.isValid()) {
        throw new Error('Invalid date');
      }
    } catch (error) {
      this.errors.push({
        code: ERROR_CODES.INVALID_DATE,
        field: this.fieldName,
        message: 'NgÃ y sinh khÃ´ng Ä‘Ãºng Ä‘á»‹nh dáº¡ng',
        value: value,
        canFix: true,
        suggestion: 'Thá»­ parse vá»›i cÃ¡c format khÃ¡c nhau'
      });
      // CÃ³ thá»ƒ fix báº±ng cÃ¡ch thá»­ nhiá»u format
      return {
        isValid: false,
        canFix: true,
        errors: this.errors,
        value: value,
        needsTransform: true
      };
    }

    // Rule 2: KhÃ´ng Ä‘Æ°á»£c lÃ  ngÃ y trong tÆ°Æ¡ng lai
    if (dateValue.isAfter(moment())) {
      this.errors.push({
        code: ERROR_CODES.INVALID_DATE,
        field: this.fieldName,
        message: 'NgÃ y sinh khÃ´ng Ä‘Æ°á»£c lÃ  ngÃ y trong tÆ°Æ¡ng lai',
        value: value,
        canFix: false
      });
      canFix = false;
    }

    // Rule 3: Tuá»•i pháº£i tá»« MIN_AGE Ä‘áº¿n MAX_AGE
    const age = moment().diff(dateValue, 'years');
    
    if (age < LIMITS.MIN_AGE) {
      this.errors.push({
        code: ERROR_CODES.OUT_OF_RANGE,
        field: this.fieldName,
        message: `Tuá»•i pháº£i tá»« ${LIMITS.MIN_AGE} trá»Ÿ lÃªn`,
        value: value,
        currentAge: age,
        canFix: false
      });
      canFix = false;
    }

    if (age > LIMITS.MAX_AGE) {
      this.errors.push({
        code: ERROR_CODES.OUT_OF_RANGE,
        field: this.fieldName,
        message: `Tuá»•i khÃ´ng Ä‘Æ°á»£c vÆ°á»£t quÃ¡ ${LIMITS.MAX_AGE}`,
        value: value,
        currentAge: age,
        canFix: false
      });
      canFix = false;
    }

    // Rule 4: NÄƒm sinh pháº£i há»£p lÃ½ (sau 1900)
    if (dateValue.year() < 1900) {
      this.errors.push({
        code: ERROR_CODES.INVALID_DATE,
        field: this.fieldName,
        message: 'NÄƒm sinh pháº£i sau nÄƒm 1900',
        value: value,
        canFix: false
      });
      canFix = false;
    }

    // Rule 5: Kiá»ƒm tra format (cÃ³ thá»ƒ fix)
    const standardFormat = dateValue.format('YYYY-MM-DD');
    if (value.toString() !== standardFormat) {
      this.errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Äá»‹nh dáº¡ng ngÃ y sinh nÃªn lÃ  YYYY-MM-DD',
        value: value,
        canFix: true,
        suggestion: `Chuyá»ƒn thÃ nh ${standardFormat}`
      });
    }

    const isValid = this.errors.length === 0;

    return {
      isValid,
      canFix: canFix && this.errors.length > 0,
      errors: this.errors,
      value: value,
      parsedDate: dateValue,
      needsTransform: this.errors.some(e => e.canFix)
    };
  }

  getErrors() {
    return this.errors;
  }

  getFieldName() {
    return this.fieldName;
  }
}

module.exports = NgaySinhRule;
```

### src\validation\rules\SoDienThoai.rule.js
```js
// src/validation/rules/SoDienThoai.rule.js
const { REGEX, ERROR_CODES } = require('../../../config/constants');

class SoDienThoaiRule {
  constructor() {
    this.fieldName = 'so_dien_thoai';
  }

  validate(value, record) {
    const errors = [];
    if (!value) {
      return { isValid: true, errors: [] }; // Cho phÃ©p null
    }

    if (!REGEX.PHONE.test(value.toString())) {
      errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Sá»‘ Ä‘iá»‡n thoáº¡i khÃ´ng há»£p lá»‡. Pháº£i báº¯t Ä‘áº§u báº±ng 0 hoáº·c +84 vÃ  cÃ³ 9-10 sá»‘ theo sau.',
        value,
        canFix: true, // CÃ³ thá»ƒ sá»­a Ä‘Æ°á»£c
        suggestion: 'Chuáº©n hÃ³a vá» Ä‘á»‹nh dáº¡ng 0xxxxxxxxx'
      });
    }

    return {
      isValid: errors.length === 0,
      canFix: errors.length > 0,
      errors: errors,
    };
  }

  getFieldName() {
    return this.fieldName;
  }
}

module.exports = SoDienThoaiRule;
```

### src\validation\rules\TrangThai.rule.js
```js
// src/validation/rules/TrangThai.rule.js - Validation cho Tráº¡ng thÃ¡i (Enum)
const { 
  TRANG_THAI_DON_HANG, 
  TRANG_THAI_THANH_TOAN,
  TRANG_THAI_PHIEU_HO_TRO,
  TRANG_THAI_NHAN_VIEN,
  ERROR_CODES 
} = require('../../../config/constants');

class TrangThaiRule {
  constructor() {
    this.fieldName = 'trang_thai';
    this.errors = [];
    
    // Map cÃ¡c báº£ng vá»›i enum tÆ°Æ¡ng á»©ng
    this.statusMaps = {
      'don_hang': Object.values(TRANG_THAI_DON_HANG),
      'thanh_toan': Object.values(TRANG_THAI_THANH_TOAN),
      'phieu_ho_tro': Object.values(TRANG_THAI_PHIEU_HO_TRO),
      'nhanvien_cskh': Object.values(TRANG_THAI_NHAN_VIEN)
    };
  }

  /**
   * Validate tráº¡ng thÃ¡i dá»±a vÃ o table context
   */
  validate(value, record, tableName = null) {
    this.errors = [];

    // Rule 1: KhÃ´ng Ä‘Æ°á»£c null
    if (!value || value.toString().trim() === '') {
      this.errors.push({
        code: ERROR_CODES.NULL_VALUE,
        field: this.fieldName,
        message: 'Tráº¡ng thÃ¡i khÃ´ng Ä‘Æ°á»£c Ä‘á»ƒ trá»‘ng',
        value: value,
        canFix: false
      });
      return {
        isValid: false,
        canFix: false,
        errors: this.errors,
        value: value
      };
    }

    value = value.toString().trim();

    // XÃ¡c Ä‘á»‹nh valid statuses dá»±a vÃ o table
    const validStatuses = this.getValidStatuses(tableName, record);

    if (!validStatuses || validStatuses.length === 0) {
      // KhÃ´ng xÃ¡c Ä‘á»‹nh Ä‘Æ°á»£c table, skip validation
      return {
        isValid: true,
        canFix: false,
        errors: [],
        value: value
      };
    }

    // Rule 2: Pháº£i thuá»™c má»™t trong cÃ¡c giÃ¡ trá»‹ há»£p lá»‡
    const isValidStatus = validStatuses.some(status => 
      status.toLowerCase() === value.toLowerCase()
    );

    if (!isValidStatus) {
      // TÃ¬m tráº¡ng thÃ¡i gáº§n giá»‘ng nháº¥t (cÃ³ thá»ƒ fix)
      const closestMatch = this.findClosestMatch(value, validStatuses);
      
      this.errors.push({
        code: ERROR_CODES.INVALID_STATUS,
        field: this.fieldName,
        message: 'Tráº¡ng thÃ¡i khÃ´ng há»£p lá»‡',
        value: value,
        validStatuses: validStatuses,
        canFix: closestMatch !== null,
        suggestion: closestMatch ? `CÃ³ thá»ƒ lÃ : ${closestMatch}` : null
      });
    }

    // Rule 3: Chuáº©n hÃ³a chá»¯ hoa/thÆ°á»ng (cÃ³ thá»ƒ fix)
    const correctStatus = validStatuses.find(status => 
      status.toLowerCase() === value.toLowerCase()
    );

    if (correctStatus && correctStatus !== value) {
      this.errors.push({
        code: ERROR_CODES.INVALID_FORMAT,
        field: this.fieldName,
        message: 'Tráº¡ng thÃ¡i cáº§n chuáº©n hÃ³a chá»¯ hoa/thÆ°á»ng',
        value: value,
        canFix: true,
        suggestion: `Chuyá»ƒn thÃ nh: ${correctStatus}`
      });
    }

    const isValid = this.errors.length === 0;
    const canFix = !isValid && this.errors.every(e => e.canFix);

    return {
      isValid,
      canFix,
      errors: this.errors,
      value: value,
      needsTransform: canFix
    };
  }

  /**
   * XÃ¡c Ä‘á»‹nh valid statuses dá»±a vÃ o table name hoáº·c record context
   */
  getValidStatuses(tableName, record) {
    // Náº¿u cÃ³ tableName
    if (tableName && this.statusMaps[tableName]) {
      return this.statusMaps[tableName];
    }

    // Thá»­ xÃ¡c Ä‘á»‹nh tá»« record (cÃ³ thá»ƒ cÃ³ field indicator)
    if (record) {
      if (record.ma_don_hang) return this.statusMaps.don_hang;
      if (record.ma_thanh_toan) return this.statusMaps.thanh_toan;
      if (record.ma_phieu_ho_tro) return this.statusMaps.phieu_ho_tro;
      if (record.ma_nhan_vien) return this.statusMaps.nhanvien_cskh;
    }

    // Merge táº¥t cáº£ (fallback)
    return [
      ...this.statusMaps.don_hang,
      ...this.statusMaps.thanh_toan,
      ...this.statusMaps.phieu_ho_tro,
      ...this.statusMaps.nhanvien_cskh
    ];
  }

  /**
   * TÃ¬m tráº¡ng thÃ¡i gáº§n giá»‘ng nháº¥t (typo correction)
   */
  findClosestMatch(value, validStatuses) {
    const valueLower = value.toLowerCase().replace(/\s+/g, '');
    
    let closestMatch = null;
    let minDistance = Infinity;

    for (const status of validStatuses) {
      const statusLower = status.toLowerCase().replace(/\s+/g, '');
      const distance = this.levenshteinDistance(valueLower, statusLower);
      
      // Náº¿u Ä‘á»™ tÆ°Æ¡ng Ä‘á»“ng > 70%
      if (distance < minDistance && distance <= statusLower.length * 0.3) {
        minDistance = distance;
        closestMatch = status;
      }
    }

    return closestMatch;
  }

  /**
   * TÃ­nh khoáº£ng cÃ¡ch Levenshtein (edit distance)
   */
  levenshteinDistance(str1, str2) {
    const len1 = str1.length;
    const len2 = str2.length;
    const matrix = [];

    for (let i = 0; i <= len1; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= len2; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= len1; i++) {
      for (let j = 1; j <= len2; j++) {
        if (str1[i - 1] === str2[j - 1]) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }

    return matrix[len1][len2];
  }

  getErrors() {
    return this.errors;
  }

  getFieldName() {
    return this.fieldName;
  }
}

module.exports = TrangThaiRule;
```


### .env
# PostgreSQL Data Source 1
DS1_HOST=ep-frosty-feather-a1fgkkhk-pooler.ap-southeast-1.aws.neon.tech
DS1_DATABASE=Data_Source_1
DS1_USER=neondb_owner
DS1_PASSWORD=npg_ev5qPxOBAn3E
DS1_PORT=5432
DS1_SSL=true

# PostgreSQL Data Source 2 (Staging)
DS2_HOST=localhost
DS2_DATABASE=staging_db
DS2_USER=postgres
DS2_PASSWORD=postgres
DS2_PORT=5433

# PostgreSQL Data Warehouse (Final)
DW_HOST=localhost
DW_DATABASE=datawarehouse
DW_USER=postgres
DW_PASSWORD=postgres
DW_PORT=5434

# RabbitMQ
RABBITMQ_URL=amqp://guest:guest@localhost:5672
QUEUE_NAME_DS1=datasource1_queue
QUEUE_NAME_DS2=datasource2_queue
QUEUE_NAME_STAGING=staging_queue

# Paths
CSV_PATH=./data/datasource2
LOG_PATH=./logs

